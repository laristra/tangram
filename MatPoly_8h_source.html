<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>tangram: /home/portage/tangram/tangram/support/MatPoly.h Source File</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_043c38e9c2239d2104f02eee845ed8d8.html">tangram</a></li><li class="navelem"><a class="el" href="dir_ac77909c0f1db96f6644ae8bc968ffe2.html">support</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MatPoly.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="MatPoly_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> This file is part of the Ristra tangram project.</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> Please see the license file at the root of this repository, or at:</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> https://github.com/laristra/tangram/blob/master/LICENSE</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#ifndef TANGRAM_MATPOLY_H_</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#define TANGRAM_MATPOLY_H_</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &lt;numeric&gt;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="tangram_8h.html">tangram/support/tangram.h</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceTangram.html">Tangram</a> {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00020"></a><span class="lineno"><a class="line" href="namespaceTangram.html#add95776fd9a423b220c590e28f32fd22">   20</a></span>&#160;<span class="keywordtype">double</span> <a class="code" href="namespaceTangram.html#add95776fd9a423b220c590e28f32fd22">polygon3d_area</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; points,</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;                      <span class="keyword">const</span> std::vector&lt;int&gt;&amp; poly_vertices,</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;                      <span class="keywordtype">double</span> dst_tol) {</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="keywordtype">double</span> poly_area = 0.0;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_vertices.size());</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keywordtype">int</span> nnz_edges = 0;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="keywordflow">if</span> (nvrts == 3) {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec[2];</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iside = 0; iside &lt; 2; iside++) {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      side_vec[iside] = points[poly_vertices[iside + 1]] - points[poly_vertices[0]];</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      <span class="keywordflow">if</span> (side_vec[iside].norm() &gt;= dst_tol) nnz_edges++;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    }</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">if</span> ((nnz_edges == 2) &amp;&amp; </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        ((points[poly_vertices[2]] - points[poly_vertices[1]]).norm() &gt;= dst_tol))</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      poly_area = 0.5*<a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec[0], side_vec[1]).norm();</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      </div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> poly_area;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  }</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point3</a> gcenter;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    gcenter += points[poly_vertices[ivrt]];</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  gcenter /= nvrts;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  </div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordtype">int</span> ifv = poly_vertices[ivrt];</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordtype">int</span> isv = poly_vertices[(ivrt + 1)%nvrts];</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec = points[isv] - points[ifv];</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">if</span> (side_vec.norm() &gt;= dst_tol) nnz_edges++;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordtype">double</span> tri_size = </div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      0.5*<a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec, gcenter - points[ifv]).norm();</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    poly_area += tri_size;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  }</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">if</span> (nnz_edges &lt; 3)</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    poly_area = 0.0;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">return</span> poly_area;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00064"></a><span class="lineno"><a class="line" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">   64</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">polygon3d_moments</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; points,</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                       <span class="keyword">const</span> std::vector&lt;int&gt;&amp; poly_vertices,</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                       std::vector&lt;double&gt;&amp; poly_moments,</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                       <span class="keywordtype">double</span> dst_tol) {</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  poly_moments.assign(4, 0.0);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_vertices.size());</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keywordtype">int</span> nnz_edges = 0;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">if</span> (nvrts == 3) {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec[2];</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iside = 0; iside &lt; 2; iside++) {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      side_vec[iside] = points[poly_vertices[iside + 1]] - points[poly_vertices[0]];</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;      <span class="keywordflow">if</span> (side_vec[iside].norm() &gt;= dst_tol) nnz_edges++;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    }</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> ((nnz_edges == 2) &amp;&amp; </div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;        ((points[poly_vertices[2]] - points[poly_vertices[1]]).norm() &gt;= dst_tol)) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      poly_moments[0] = 0.5*<a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec[0], side_vec[1]).norm();</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; 3; ivrt++)</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;          poly_moments[idim + 1] += points[poly_vertices[ivrt]][idim];</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)    </div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        poly_moments[idim + 1] *= poly_moments[0]/3.0;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  }</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point3</a> gcenter;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    gcenter += points[poly_vertices[ivrt]];</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  gcenter /= nvrts;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  </div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordtype">int</span> ifv = poly_vertices[ivrt];</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordtype">int</span> isv = poly_vertices[(ivrt + 1)%nvrts];</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec = points[isv] - points[ifv];</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span> (side_vec.norm() &gt;= dst_tol) nnz_edges++;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordtype">double</span> tri_size = </div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;      0.5*<a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec, gcenter - points[ifv]).norm();</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    poly_moments[0] += tri_size;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;      poly_moments[idim + 1] += </div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        tri_size*(points[ifv][idim] + points[isv][idim] + gcenter[idim])/3.0;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  }</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordflow">if</span> (nnz_edges &lt; 3)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    poly_moments.assign(4, 0.0);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;}</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00118"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">  118</a></span>&#160;<a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> <a class="code" href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">polygon3d_normal</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; points,</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                           <span class="keyword">const</span> std::vector&lt;int&gt;&amp; poly_vertices,</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                           <span class="keywordtype">double</span> dst_tol) {</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <a class="code" href="classTangram_1_1Vector.html">Vector3</a> poly_normal(0.0, 0.0, 0.0);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_vertices.size());</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  <span class="keywordflow">if</span> (nvrts == 3) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordtype">int</span> nnz_edges = 0;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec[2];</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iside = 0; iside &lt; 2; iside++) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      side_vec[iside] = points[poly_vertices[iside + 1]] - points[poly_vertices[0]];</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      <span class="keywordflow">if</span> (side_vec[iside].norm() &gt;= dst_tol) nnz_edges++;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <span class="keywordflow">if</span> ((nnz_edges == 2) &amp;&amp; </div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        ((points[poly_vertices[2]] - points[poly_vertices[1]]).norm() &gt;= dst_tol)) {</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      poly_normal = <a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec[0], side_vec[1]);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;      poly_normal.<a class="code" href="classTangram_1_1Vector.html#a15d0c4cf8f5b7529f4e0895ab6e6c933">normalize</a>();</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">return</span> poly_normal;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  std::vector&lt;double&gt; poly_moments;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <a class="code" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">polygon3d_moments</a>(points, poly_vertices, poly_moments, dst_tol);</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;  <span class="keywordflow">if</span> (poly_moments[0] == 0.0)</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordflow">return</span> poly_normal;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point3</a> poly_centroid;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    poly_centroid[idim] = poly_moments[idim + 1]/poly_moments[0];</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> side_vec = points[poly_vertices[(ivrt + 1)%nvrts]] - </div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                         points[poly_vertices[ivrt]];</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <a class="code" href="classTangram_1_1Vector.html">Vector&lt;3&gt;</a> tri_normal = <a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(side_vec, poly_centroid - points[poly_vertices[ivrt]]);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    poly_normal += tri_normal;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;  }</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  poly_normal.<a class="code" href="classTangram_1_1Vector.html#a15d0c4cf8f5b7529f4e0895ab6e6c933">normalize</a>();</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;  <span class="keywordflow">return</span> poly_normal;  </div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;}</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> D&gt;</div><div class="line"><a name="l00163"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html">  163</a></span>&#160;<span class="keyword">class </span><a class="code" href="classTangram_1_1MatPoly.html">MatPoly</a> {</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160; <span class="keyword">public</span>:</div><div class="line"><a name="l00169"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#acc2a5d89ddc811f6acb3ef4d4780d753">  169</a></span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html#acc2a5d89ddc811f6acb3ef4d4780d753">MatPoly</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> material_id = -1) : material_id_(material_id) {}</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#acf9b8b3197a7b4dd7089042843020fa3">  172</a></span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html#acf9b8b3197a7b4dd7089042843020fa3">~MatPoly</a>() {}</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aac14f299f075ed1688c24103e1b268ac">  178</a></span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">MatPoly</a>&amp; <a class="code" href="classTangram_1_1MatPoly.html#aac14f299f075ed1688c24103e1b268ac">operator=</a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html">MatPoly</a>&amp; source_poly) {</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    material_id_ = source_poly.material_id_;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    vertex_points_ = source_poly.vertex_points_;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    face_vertices_ = source_poly.face_vertices_;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    dst_tol_ = source_poly.dst_tol_;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    nvertices_ = source_poly.nvertices_;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    nfaces_ = source_poly.nfaces_;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    moments_ = source_poly.moments_;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  </div><div class="line"><a name="l00192"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#ace8b5fde89a513f0e9467f3ce8796e50">  192</a></span>&#160;  <span class="keywordtype">int</span> <a class="code" href="classTangram_1_1MatPoly.html#ace8b5fde89a513f0e9467f3ce8796e50">mat_id</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> material_id_; }</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a4de137538d76c83a6b56f71e6ac7a602">  198</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a4de137538d76c83a6b56f71e6ac7a602">set_mat_id</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html#ace8b5fde89a513f0e9467f3ce8796e50">mat_id</a>) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    assert(mat_id &gt;= 0);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    material_id_ = <a class="code" href="classTangram_1_1MatPoly.html#ace8b5fde89a513f0e9467f3ce8796e50">mat_id</a>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  </div><div class="line"><a name="l00208"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">  208</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">reset_mat_id</a>() { material_id_ = -1; }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">  213</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">clear</a>() {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    material_id_ = -1;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    vertex_points_.clear();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    face_vertices_.clear();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    nvertices_ = 0;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    nfaces_ = 0;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    moments_.clear();    </div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(<span class="keyword">const</span> std::vector&lt;Point2&gt;&amp; poly_points,</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; vertex_points,</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                  <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;int&gt; &gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>,</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  </div><div class="line"><a name="l00245"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">  245</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dst_tol_; }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aa756cca3df1a498d170bc3a86e6bae7b">  251</a></span>&#160;  <span class="keyword">const</span> std::vector&lt; Point&lt;D&gt; &gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#aa756cca3df1a498d170bc3a86e6bae7b">points</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vertex_points_; }</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aab5cfa3fff9b96d2cbf96415fe7704af">  258</a></span>&#160;  <span class="keyword">const</span> std::vector&lt;int&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#aab5cfa3fff9b96d2cbf96415fe7704af">face_vertices</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> face_id)<span class="keyword"> const </span>{</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    assert((face_id &gt;= 0) &amp;&amp; (face_id &lt; nfaces_));</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">return</span> face_vertices_[face_id];</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  }</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  </div><div class="line"><a name="l00270"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a5d4e12c797bbbaae17e97908cecd5b24">  270</a></span>&#160;  std::vector&lt; Point&lt;D&gt; &gt; <a class="code" href="classTangram_1_1MatPoly.html#a5d4e12c797bbbaae17e97908cecd5b24">face_points</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> face_id)<span class="keyword"> const </span>{</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    assert((face_id &gt;= 0) &amp;&amp; (face_id &lt; nfaces_));</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_vertices_[face_id].size());</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    std::vector&lt; Point&lt;D&gt; &gt; fpoints;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    fpoints.reserve(nvrts);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;      fpoints.push_back(vertex_points_[face_vertices_[face_id][ivrt]]);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keywordflow">return</span> fpoints;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  }</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">  287</a></span>&#160;  <span class="keyword">const</span> std::vector&lt;std::vector&lt;int&gt;&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">return</span> face_vertices_;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  </div><div class="line"><a name="l00296"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#ac6c290557b576c6aad5051d57a5b5685">  296</a></span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point&lt;D&gt;</a> <a class="code" href="classTangram_1_1MatPoly.html#ac6c290557b576c6aad5051d57a5b5685">vertex_point</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> vertex_id)<span class="keyword"> const </span>{</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    assert((vertex_id &gt;= 0) &amp;&amp; (vertex_id &lt; nvertices_));</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">return</span> vertex_points_[vertex_id];</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  }</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  </div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point&lt;D&gt;</a> <a class="code" href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">face_centroid</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> face_id) <span class="keyword">const</span>;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  </div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">faceted_matpoly</a>(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a>* faceted_poly) <span class="keyword">const</span>;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">faceted_matpoly</a>(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>* faceted_poly) <span class="keyword">const</span>;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  </div><div class="line"><a name="l00328"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aa32646522284f28e04aad59e815542f1">  328</a></span>&#160;  <span class="keywordtype">int</span> <a class="code" href="classTangram_1_1MatPoly.html#aa32646522284f28e04aad59e815542f1">num_vertices</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nvertices_; }</div><div class="line"><a name="l00333"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a82d4a7bb4295c65916aaec1cc03b9a00">  333</a></span>&#160;  <span class="keywordtype">int</span> <a class="code" href="classTangram_1_1MatPoly.html#a82d4a7bb4295c65916aaec1cc03b9a00">num_faces</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nfaces_; }</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">  341</a></span>&#160;  <span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keywordflow">if</span> (moments_.empty())</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">compute_moments</a>(moments_);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">return</span> moments_;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  }</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  </div><div class="line"><a name="l00354"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#abaf29e137ee4fa958dccc7fa7e7ea785">  354</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#abaf29e137ee4fa958dccc7fa7e7ea785">assign_moments</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    assert(moments.size() == D + 1);</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="preprocessor">#endif    </span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    moments_ = <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;D&gt;</a> &gt;&amp; sub_polys) <span class="keyword">const</span>;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">facetize_decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;D&gt;</a> &gt;&amp; sub_polys) <span class="keyword">const</span>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">face_planes</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;D&gt;</a> &gt;&amp; fplanes) <span class="keyword">const</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div><div class="line"><a name="l00390"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aff224788989415116c567aabc00f578b">  390</a></span>&#160;  <a class="code" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t&lt;D&gt;</a> <a class="code" href="classTangram_1_1MatPoly.html#aff224788989415116c567aabc00f578b">bounding_box</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <a class="code" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t&lt;D&gt;</a> bbox;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvertices_; ivrt++)</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; D; idim++) {</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        <span class="keywordflow">if</span> (vertex_points_[ivrt][idim] &lt; bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">min</a>[idim])</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;          bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">min</a>[idim] = vertex_points_[ivrt][idim];</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">if</span> (vertex_points_[ivrt][idim] &gt; bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">max</a>[idim])</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;          bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">max</a>[idim] = vertex_points_[ivrt][idim];        </div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      }</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">return</span> bbox;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160; <span class="keyword">protected</span>:</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">compute_moments</a>(std::vector&lt;double&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>) <span class="keyword">const</span>;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160; <span class="keyword">private</span>:</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  <span class="keywordtype">int</span> material_id_;  <span class="comment">// material ID of this matpoly</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  std::vector&lt; Point&lt;D&gt; &gt; vertex_points_;  <span class="comment">// coordinates of vertices</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; face_vertices_;  <span class="comment">// vertices of faces</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  <span class="keywordtype">double</span> dst_tol_; <span class="comment">// distance tolerance</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  </div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  <span class="keywordtype">int</span> nvertices_ = 0;  <span class="comment">// number of vertices</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="keywordtype">int</span> nfaces_ = 0;  <span class="comment">//number of faces</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="keyword">mutable</span> std::vector&lt;double&gt; moments_; <span class="comment">//moments of this matpoly</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;};  <span class="comment">// class MatPoly</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00429"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a21be391f3de4842652d4145fbe74bdbb">  429</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">MatPoly&lt;2&gt;::initialize</a>(<span class="keyword">const</span> std::vector&lt;Point2&gt;&amp; poly_points, </div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                            <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  dst_tol_ = <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  nvertices_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_points.size());</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  assert(nvertices_ &gt; 2);</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  nfaces_ = nvertices_;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; </div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  vertex_points_ = poly_points;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  face_vertices_.resize(nfaces_);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++)</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    face_vertices_[iface] = { iface, (iface + 1)%nfaces_ };</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;}</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00452"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a20c897a6444c35eaefa99b683720ec82">  452</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">MatPoly&lt;3&gt;::initialize</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; vertex_points,</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                            <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;int&gt; &gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>,</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                            <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  dst_tol_ = <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  nvertices_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(vertex_points.size());</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  nfaces_ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>.size());</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  assert(nvertices_ &gt; 3);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  assert(nfaces_ &gt; 3);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  </div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  vertex_points_ = vertex_points;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;  face_vertices_ = <a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;}</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00474"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#af4f47fcc06132bad3521868453cf1a2d">  474</a></span>&#160;<a class="code" href="classTangram_1_1Point.html">Point2</a> <a class="code" href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">MatPoly&lt;2&gt;::face_centroid</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> face_id)<span class="keyword"> const </span>{</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  assert((face_id &gt;= 0) &amp;&amp; (face_id &lt; nfaces_));</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  <span class="keywordflow">return</span> 0.5*(vertex_points_[face_id] + vertex_points_[(face_id + 1)%nvertices_]);</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00488"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a3e294fac6eb0f5ae91d1a2cd30840c53">  488</a></span>&#160;<a class="code" href="classTangram_1_1Point.html">Point3</a> <a class="code" href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">MatPoly&lt;3&gt;::face_centroid</a>(<span class="keywordtype">int</span> <span class="keyword">const</span> face_id)<span class="keyword"> const </span>{</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="preprocessor">#ifdef DEBUG</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  assert((face_id &gt;= 0) &amp;&amp; (face_id &lt; nfaces_));</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  std::vector&lt;double&gt; face_moments;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <a class="code" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">polygon3d_moments</a>(vertex_points_, face_vertices_[face_id], face_moments, dst_tol_);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="keywordflow">if</span> (face_moments[0] != 0.0)</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a>(face_moments[1]/face_moments[0], face_moments[2]/face_moments[0],</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;                  face_moments[3]/face_moments[0]);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  <span class="keywordflow">else</span> {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_vertices_[face_id].size());</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <a class="code" href="classTangram_1_1Point.html">Point3</a> gcenter;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;      gcenter += vertex_points_[face_vertices_[face_id][ivrt]];</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    gcenter /= nvrts;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="keywordflow">return</span> gcenter;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;  }</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;}</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00516"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a3b43487edeeeb1e8af3bb751a0c15a90">  516</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">MatPoly&lt;2&gt;::faceted_matpoly</a>(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a>* faceted_poly)<span class="keyword"> const </span>{</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  *faceted_poly = *<span class="keyword">this</span>;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;}</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00528"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a9f3a511d6558db3f43f32d00511ed3e6">  528</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">MatPoly&lt;3&gt;::faceted_matpoly</a>(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>* faceted_poly)<span class="keyword"> const </span>{</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;  <span class="keywordflow">if</span> (material_id_ &gt;= 0)</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    faceted_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a4de137538d76c83a6b56f71e6ac7a602">set_mat_id</a>(material_id_);</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    faceted_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">reset_mat_id</a>();</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  std::vector&lt;Point3&gt; facetedpoly_vertices = vertex_points_;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; facetedpoly_faces_;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  facetedpoly_faces_.reserve(nfaces_);</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_vertices_[iface].size());</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordflow">if</span> (nvrts == 3) {</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      facetedpoly_faces_.push_back(face_vertices_[iface]);</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    }</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordtype">int</span> icenvrt = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(facetedpoly_vertices.size());</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    facetedpoly_vertices.push_back(<a class="code" href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">face_centroid</a>(iface));</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;      facetedpoly_faces_.push_back({ icenvrt, face_vertices_[iface][ivrt],</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                                     face_vertices_[iface][(ivrt + 1)%nvrts] });</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  }</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  </div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  faceted_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(facetedpoly_vertices, facetedpoly_faces_, dst_tol_);</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="keywordflow">if</span> (!moments_.empty())</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    faceted_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#abaf29e137ee4fa958dccc7fa7e7ea785">assign_moments</a>(moments_);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;}</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00562"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a15c10f97eed244f38129f07ea32a0f3d">  562</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">MatPoly&lt;2&gt;::compute_moments</a>(std::vector&lt;double&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  moments.assign(3, 0.0);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvertices_; ivrt++) {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    <span class="keywordtype">double</span> cur_term = vertex_points_[ivrt][0]*vertex_points_[(ivrt + 1)%nvertices_][1] - </div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                      vertex_points_[ivrt][1]*vertex_points_[(ivrt + 1)%nvertices_][0];</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    moments[0] += cur_term;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 2; idim++)</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;      moments[idim + 1] += cur_term*(</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        vertex_points_[ivrt][idim] + vertex_points_[(ivrt + 1)%nvertices_][idim]);</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  }</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  moments[0] /= 2.0;  </div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 2; idim++)</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    moments[idim + 1] /= 6.0;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;}</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="keyword">template</span>&lt;&gt;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00585"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a116dfc13f6bb75fc9e22ddde18552b46">  585</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">MatPoly&lt;3&gt;::compute_moments</a>(std::vector&lt;double&gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  moments.assign(4, 0.0); </div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    std::vector&lt;double&gt; face_moments;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    <a class="code" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">polygon3d_moments</a>(vertex_points_, face_vertices_[iface], face_moments, dst_tol_);</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="keywordflow">if</span> (face_moments[0] == 0.0)</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    std::vector&lt;Point3&gt; face_pts = <a class="code" href="classTangram_1_1MatPoly.html#a5d4e12c797bbbaae17e97908cecd5b24">face_points</a>(iface);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    std::vector&lt; std::vector&lt;int&gt; &gt; itri_pts;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    </div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordtype">int</span> nvrts = face_vertices_[iface].size();</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">if</span> (nvrts == 3)</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      itri_pts.push_back({0, 1, 2});</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      itri_pts.reserve(nvrts);</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      face_pts.push_back(<a class="code" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a>(face_moments[1]/face_moments[0],</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        face_moments[2]/face_moments[0], face_moments[3]/face_moments[0]));</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        itri_pts.push_back({nvrts, ivrt, (ivrt + 1)%nvrts});</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    }</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> itri = 0; itri &lt; itri_pts.size(); itri++) {</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;      <a class="code" href="classTangram_1_1Vector.html">Vector3</a> vcp = <a class="code" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a>(face_pts[itri_pts[itri][1]] - face_pts[itri_pts[itri][0]], </div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                          face_pts[itri_pts[itri][2]] - face_pts[itri_pts[itri][0]]);</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;      moments[0] += <a class="code" href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">dot</a>(vcp, face_pts[itri_pts[itri][0]].asV());</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; 3; ivrt++)</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;          moments[idim + 1] += vcp[idim]*pow(face_pts[itri_pts[itri][ivrt]][idim] + </div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;                                             face_pts[itri_pts[itri][(ivrt + 1)%3]][idim], 2);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    }</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;  }</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;  moments[0] /= 6.0;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    moments[idim + 1] /= 48.0;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;}</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00634"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#ae7e827f101bd68b9c8643bc0e4276ba2">  634</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">MatPoly&lt;2&gt;::decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a> &gt;&amp; sub_polys)<span class="keyword"> const </span>{</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  std::vector&lt;double&gt; <a class="code" href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">moments</a>;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <span class="keywordflow">if</span> (moments_.empty()) </div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">compute_moments</a>(moments_);</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point2</a> matpoly_cen;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixy = 0; ixy &lt; 2; ixy++)</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    matpoly_cen[ixy] = moments_[ixy + 1]/moments_[0];</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keywordtype">int</span> offset = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(sub_polys.size());</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  sub_polys.resize(offset + nfaces_);</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    std::vector&lt;Point2&gt; subpoly_points = <a class="code" href="classTangram_1_1MatPoly.html#a5d4e12c797bbbaae17e97908cecd5b24">face_points</a>(iface);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    subpoly_points.push_back(matpoly_cen);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    sub_polys[offset + iface].initialize(subpoly_points, dst_tol_);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  }</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;}</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00662"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aeb217fbc478559061f1d9a15302754fe">  662</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">MatPoly&lt;3&gt;::decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> &gt;&amp; sub_polys)<span class="keyword"> const </span>{</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  <span class="keywordflow">if</span> (moments_.empty()) </div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">compute_moments</a>(moments_);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  <a class="code" href="classTangram_1_1Point.html">Point3</a> matpoly_cen;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    matpoly_cen[ixyz] = moments_[ixyz + 1]/moments_[0];</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  <span class="keywordtype">int</span> offset = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(sub_polys.size());</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  sub_polys.resize(offset + nfaces_);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;    <span class="keywordtype">int</span> face_nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_vertices_[iface].size());</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    std::vector&lt;Point3&gt; subpoly_vrts(face_nvrts + 1);</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    std::vector&lt; std::vector&lt;int&gt; &gt; subpoly_faces(face_nvrts + 1);</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; face_nvrts; ivrt++) {</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;      subpoly_vrts[ivrt] = vertex_points_[face_vertices_[iface][ivrt]];</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;      subpoly_faces[ivrt] = {face_nvrts, (ivrt + 1)%face_nvrts, ivrt};</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    }</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    subpoly_vrts[face_nvrts] = matpoly_cen;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    subpoly_faces[face_nvrts].resize(face_nvrts);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    std::iota(subpoly_faces[face_nvrts].begin(), </div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;              subpoly_faces[face_nvrts].end(), 0);      </div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    </div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    sub_polys[offset + iface].initialize(subpoly_vrts, subpoly_faces, dst_tol_);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  }</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;}</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00700"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a83ef428cceacc7a027e4d0f6318083be">  700</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">MatPoly&lt;2&gt;::facetize_decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a> &gt;&amp; sub_polys)<span class="keyword"> const </span>{</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">decompose</a>(sub_polys);</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00713"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#aaf06a4d1872ec40eadeaa264a5b75db7">  713</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">MatPoly&lt;3&gt;::facetize_decompose</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> &gt;&amp; sub_polys)<span class="keyword"> const </span>{</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; tet_faces(4);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; 3; ivrt++)</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    tet_faces[ivrt] = {3, (ivrt + 1)%3, ivrt};</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  tet_faces[3] = {0, 1, 2};  </div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  <span class="keywordflow">if</span> (moments_.empty()) </div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">compute_moments</a>(moments_);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  std::vector&lt;Point3&gt; tet_vrts(4);</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    tet_vrts[3][ixyz] = moments_[ixyz + 1]/moments_[0];</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    <span class="keywordtype">int</span> face_nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_vertices_[iface].size());</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;    <span class="keywordflow">if</span> (face_nvrts == 3) {</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; 3; ivrt++)</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        tet_vrts[ivrt] = vertex_points_[face_vertices_[iface][ivrt]];</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;      <span class="keywordtype">int</span> icur_poly = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(sub_polys.size());</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      sub_polys.push_back(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>(material_id_));</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;      sub_polys[icur_poly].initialize(tet_vrts, tet_faces, dst_tol_);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    }</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;      tet_vrts[0] = <a class="code" href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">face_centroid</a>(iface);</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; face_nvrts; ivrt++) {</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        tet_vrts[1] = vertex_points_[face_vertices_[iface][ivrt]];</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        tet_vrts[2] = vertex_points_[face_vertices_[iface][(ivrt + 1)%face_nvrts]];</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="keywordtype">int</span> icur_poly = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(sub_polys.size());</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        sub_polys.push_back(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>(material_id_));</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;        sub_polys[icur_poly].initialize(tet_vrts, tet_faces, dst_tol_);</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;      }</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    }</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;  }</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;}</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00762"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">  762</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">cell_get_matpoly</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; Mesh,</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                      <span class="keyword">const</span> <span class="keywordtype">int</span> cellid,</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                      <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a>* mat_poly,</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="preprocessor">#ifdef DEBUG                        </span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;  assert(Mesh.space_dimension() == 2);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  mat_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">reset_mat_id</a>();</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  std::vector&lt;Point2&gt; poly_points;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;  Mesh.cell_get_coordinates(cellid, &amp;poly_points);</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;  mat_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(poly_points, dst_tol);</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;}</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00790"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a0e78b490c82464a056ec64a36ee2e387">  790</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">cell_get_matpoly</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; Mesh,</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                      <span class="keyword">const</span> <span class="keywordtype">int</span> cellid,</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                      <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>* mat_poly,</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="preprocessor">#ifdef DEBUG                        </span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;  assert(Mesh.space_dimension() == 3);</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;  mat_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">reset_mat_id</a>();</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;  std::vector&lt;Point3&gt; poly_points;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; poly_faces;</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  std::vector&lt;int&gt; cnodes;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  Mesh.cell_get_nodes(cellid, &amp;cnodes);</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;  <span class="keywordtype">int</span> ncnodes = cnodes.size();</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  poly_points.resize(ncnodes);</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; ncnodes; ++n)</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    Mesh.node_get_coordinates(cnodes[n], &amp;poly_points[n]);</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  std::vector&lt;int&gt; cfaces, cfdirs;</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  Mesh.cell_get_faces_and_dirs(cellid, &amp;cfaces, &amp;cfdirs);</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  <span class="keywordtype">int</span> ncfaces = cfaces.size();</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f = 0; f &lt; ncfaces; f++) {</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    std::vector&lt;int&gt; fnodes;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    Mesh.face_get_nodes(cfaces[f], &amp;fnodes);</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    <span class="keywordtype">int</span> nfnodes = fnodes.size();</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    </div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    <span class="comment">//Check that the order of nodes is ccw</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;    <span class="keywordflow">if</span> (cfdirs[f] != 1)</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;      std::reverse(fnodes.begin(), fnodes.end());</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    <span class="comment">// Get the local indices (in the cell node list) of the face nodes</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    std::vector&lt;int&gt; fnodes_local(nfnodes);</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; nfnodes; n++) {</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;      fnodes_local[n] = std::distance(cnodes.begin(),</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;        std::find(cnodes.begin(), cnodes.end(), fnodes[n]));</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      assert(fnodes_local[n] != ncnodes);</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    }</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;    poly_faces.emplace_back(fnodes_local);</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;  }</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  mat_poly-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(poly_points, poly_faces, dst_tol);</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;}</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00844"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#af3b7e4023fdf489773ca52943d41006f">  844</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">MatPoly&lt;2&gt;::face_planes</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;2&gt;</a> &gt;&amp; flines)<span class="keyword"> const </span>{</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;  flines.clear();</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;    <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;2&gt;</a> face_line;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    face_line.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>[0] = vertex_points_[face_vertices_[iface][1]][1] - </div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;                          vertex_points_[face_vertices_[iface][0]][1];</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    face_line.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>[1] = -(vertex_points_[face_vertices_[iface][1]][0] - </div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;                            vertex_points_[face_vertices_[iface][0]][0]);</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="keywordtype">double</span> normal_len = face_line.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>.norm();</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;    <span class="keywordflow">if</span> (normal_len &gt;= dst_tol_) {</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;      face_line.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a> /= normal_len;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;      face_line.<a class="code" href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">dist2origin</a> = </div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;        -<a class="code" href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">dot</a>(vertex_points_[face_vertices_[iface][0]].asV(), face_line.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>);</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;      flines.push_back(face_line); </div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    }</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;  }</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  <span class="keywordflow">if</span> (flines.size() &lt; 3)</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    flines.clear();</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;}</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00878"></a><span class="lineno"><a class="line" href="classTangram_1_1MatPoly.html#a3139b7f9d551301f2c70240eb460fa7b">  878</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">MatPoly&lt;3&gt;::face_planes</a>(<a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a> &gt;&amp; fplanes)<span class="keyword"> const </span>{</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;  fplanes.clear();</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces_; iface++) {</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a> face_plane;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    face_plane.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a> = <a class="code" href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">polygon3d_normal</a>(vertex_points_, face_vertices_[iface], </div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;                                         dst_tol_);</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;    <span class="keywordflow">if</span> (face_plane.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>.is_zero(dst_tol_))</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    </div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;    face_plane.<a class="code" href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">dist2origin</a> = </div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;      -<a class="code" href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">dot</a>(vertex_points_[face_vertices_[iface][0]].asV(), face_plane.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>);</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;    fplanes.push_back(face_plane);  </div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  }</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;  <span class="keywordflow">if</span> (fplanes.size() &lt; 4)</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;    fplanes.clear();</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;}</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00906"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a69297ec3a4d9448be375b217d7297fe9">  906</a></span>&#160;<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a> <a class="code" href="namespaceTangram.html#a69297ec3a4d9448be375b217d7297fe9">natural_selection</a>(<span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Point&lt;2&gt;</a> &gt;&amp; poly_points,</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                             <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>,</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                             <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Point&lt;2&gt;</a> &gt;* reference_pts = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;2&gt;</a> fit_poly;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;  <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(poly_points.size());</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;  std::vector&lt; Point&lt;2&gt; &gt; unique_points;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  unique_points.reserve(nvrts);</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    <span class="comment">// Check if this point is coincident with the next one,</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    <span class="comment">// i.e. if the respective edge is degenerate: points </span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;    <span class="comment">// are considered coincident if the distance between them</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="comment">// is below the distance tolerance</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    <span class="keywordflow">if</span> ((poly_points[ivrt] - poly_points[(ivrt + 1)%nvrts]).norm() &gt;= dst_tol) {</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;      <span class="keywordtype">bool</span> reference_match = <span class="keyword">false</span>;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;      <span class="keywordflow">if</span> (reference_pts != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irp = 0; irp &lt; reference_pts-&gt;size(); irp++)</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;          <span class="keywordflow">if</span> ((poly_points[ivrt] - (*reference_pts)[irp]).norm() &lt; <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            unique_points.push_back((*reference_pts)[irp]);</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            reference_match = <span class="keyword">true</span>;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            <span class="keywordflow">break</span>;  </div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;          }</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;      }</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;      <span class="keywordflow">if</span> (!reference_match)</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;        unique_points.push_back(poly_points[ivrt]);</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    }</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  }</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;  unique_points.shrink_to_fit();</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;  <span class="comment">// Polygons with less than three vertices are clearly degenerate</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;  <span class="keywordflow">if</span> (unique_points.size() &gt; 2)</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    fit_poly.<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(unique_points, dst_tol);</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;  <span class="keywordflow">return</span> fit_poly;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;}</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l00955"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a9cf0201d875a729c2ab615434bf540e5">  955</a></span>&#160;<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> <a class="code" href="namespaceTangram.html#a69297ec3a4d9448be375b217d7297fe9">natural_selection</a>(<span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; vertex_points,</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                             <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;int&gt; &gt;&amp; <a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>,</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                             <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>,</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                             <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Point&lt;3&gt;</a> &gt;* reference_pts = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> fit_poly;</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;  <span class="keywordtype">int</span> nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(vertex_points.size());</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;  std::vector&lt;Point3&gt; unique_vrts;</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;  unique_vrts.reserve(nvrts);</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;  <span class="comment">// We only store unique vertices, so we need a map from the original node indices</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;  <span class="comment">// to unique node indices for when we process faces</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;  std::vector&lt;int&gt; orig2unique_vrt_ids(nvrts, -1);</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; unique_vrts.size(); i++) {</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      <span class="comment">// Check if this point is coincident with a stored one: points </span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      <span class="comment">// are considered coincident if the distance between them is below</span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;      <span class="comment">// the distance tolerance</span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;      <span class="keywordflow">if</span> ((vertex_points[ivrt] - unique_vrts[i]).norm() &lt; <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;        orig2unique_vrt_ids[ivrt] = i;</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;      }</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    }</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <span class="comment">// If the point is unique, we store it</span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    <span class="keywordflow">if</span> (orig2unique_vrt_ids[ivrt] == -1) {</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;      orig2unique_vrt_ids[ivrt] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(unique_vrts.size());</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;      <span class="keywordtype">bool</span> reference_match = <span class="keyword">false</span>;</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;      <span class="keywordflow">if</span> (reference_pts != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;        <span class="comment">// We check if this point matches any of the reference ones</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irp = 0; irp &lt; reference_pts-&gt;size(); irp++) {</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;          <span class="keyword">const</span> <a class="code" href="classTangram_1_1Point.html">Point&lt;3&gt;</a>&amp; cur_ref_pt = (*reference_pts)[irp];</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;          <span class="keywordflow">if</span> ((vertex_points[ivrt] - cur_ref_pt).norm() &lt; <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>) {            </div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;            unique_vrts.push_back(cur_ref_pt);            </div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            reference_match = <span class="keyword">true</span>;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;            <span class="keywordflow">break</span>; </div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;          }</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;        }</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;      }</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;      <span class="keywordflow">if</span> (!reference_match)</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        unique_vrts.push_back(vertex_points[ivrt]);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    }</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;  }</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  unique_vrts.shrink_to_fit();</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;  nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(unique_vrts.size());</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  <span class="comment">// Check if it still has a chance to be at least a tetrahedron</span></div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;  <span class="keywordflow">if</span> (nvrts &lt; 4) <span class="keywordflow">return</span> fit_poly;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  <span class="comment">//First pass on faces: have them reference only unique vertices</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;  <span class="keywordtype">int</span> nfaces = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>.size());</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; face_unique_vrts(nfaces);</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++) {</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    <span class="keywordtype">int</span> face_nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>[iface].size());</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifv = 0; ifv &lt; face_nvrts; ifv++) {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;      <span class="keywordtype">int</span> cur_vrt_id = orig2unique_vrt_ids[<a class="code" href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">face_vertices</a>[iface][ifv]];</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;      <span class="comment">// There can be only one (c) such index in the list of face indices</span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;      <span class="keywordflow">if</span> (std::find(face_unique_vrts[iface].begin(), face_unique_vrts[iface].end(), </div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;                    cur_vrt_id) == face_unique_vrts[iface].end())</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;        face_unique_vrts[iface].push_back(cur_vrt_id);</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    }</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  }</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;  <span class="comment">// Hanging vertices can be a problem, so we first find how many unique</span></div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;  <span class="comment">// connections is in each vertice&#39;s network</span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; connected_vrt_ids(nvrts);</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;  std::vector&lt; std::vector&lt; std::pair&lt;int, int&gt; &gt; &gt; vrt_in_faces(nvrts);</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; face_unique_vrts.size(); iface++) {</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;      <span class="keyword">const</span> std::vector&lt;int&gt;&amp; cur_face_vrts = face_unique_vrts[iface];</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;      <span class="keywordtype">int</span> nface_vrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_face_vrts.size());</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;      <span class="keywordtype">int</span> id_in_face = std::distance(cur_face_vrts.begin(),</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;                                     std::find(cur_face_vrts.begin(),</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                                               cur_face_vrts.end(), ivrt));</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;      </div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;      <span class="keywordflow">if</span> (id_in_face != nface_vrts) {</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;        <span class="comment">// Vertex is in the current face</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;        vrt_in_faces[ivrt].push_back(std::pair&lt;int, int&gt;(iface, id_in_face));</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        <span class="comment">// We check if it has unknown connections with vertices of the current face</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p0n1 = 0; p0n1 &lt; 2; p0n1++) {</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;          <span class="keywordtype">int</span> adj_vrt_face_id = (nface_vrts + id_in_face + 2*p0n1 - 1)%nface_vrts;</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;          <span class="keywordtype">int</span> adj_vrt_id = face_unique_vrts[iface][adj_vrt_face_id];</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;          <span class="keywordflow">if</span> (std::find(connected_vrt_ids[ivrt].begin(), connected_vrt_ids[ivrt].end(),</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;                        adj_vrt_id) == connected_vrt_ids[ivrt].end())</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;            connected_vrt_ids[ivrt].push_back(adj_vrt_id);</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;        }</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;      }</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;    }      </div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;  }</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;  <span class="comment">// Now we dispose of hanger-on vertices that don&#39;t have enough connections</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  <span class="comment">// This also affects the connections of vertices which they networked with,</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;  <span class="comment">// so we need to check if those get dragged down the cliff as well</span></div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;  <span class="keywordtype">bool</span> dropped_connections;</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;  std::vector&lt;int&gt; hanging_vrts_ids;</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;  <span class="keywordflow">do</span> {</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    dropped_connections = <span class="keyword">false</span>;</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;      <span class="keywordtype">int</span> ncv = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(connected_vrt_ids[ivrt].size());</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;      <span class="keywordflow">if</span> (ncv &lt; 3) {</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;        hanging_vrts_ids.push_back(ivrt);</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;        <span class="comment">// Others break connections first</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icv = 0; icv &lt; ncv; icv++) {</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;          <span class="keywordtype">int</span> icvrt = connected_vrt_ids[ivrt][icv];</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;          connected_vrt_ids[icvrt].erase(</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;            std::find(connected_vrt_ids[icvrt].begin(), </div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                      connected_vrt_ids[icvrt].end(), ivrt));</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        }</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;        <span class="keywordflow">if</span> (ncv == 1) dropped_connections = <span class="keyword">true</span>;</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;        <span class="keywordtype">bool</span> third_wheel = <span class="keyword">false</span>;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icf = 0; icf &lt; vrt_in_faces[ivrt].size(); icf++) {</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;          <span class="keywordtype">int</span> iface = vrt_in_faces[ivrt][icf].first;</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;          <span class="keywordtype">int</span> hvrt_fid = vrt_in_faces[ivrt][icf].second;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;          <span class="comment">// Check if the two others can connect by themselves</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;          <span class="keywordflow">if</span> (ncv == 2) {</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;            <span class="keywordtype">int</span> nface_vrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_unique_vrts[iface].size());</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icv = 0; icv &lt; 2; icv++)</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;              <span class="keywordflow">if</span> ( (face_unique_vrts[iface][(hvrt_fid + 1)%nface_vrts] ==</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;                    connected_vrt_ids[ivrt][(icv + 1)%2]) &amp;&amp;</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;                   (face_unique_vrts[iface][(nface_vrts + hvrt_fid - 1)%nface_vrts] ==</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;                    connected_vrt_ids[ivrt][icv]) ) {</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;                third_wheel = <span class="keyword">true</span>;</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; i++)</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;                  connected_vrt_ids[connected_vrt_ids[ivrt][i]].push_back(</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;                    connected_vrt_ids[ivrt][(i + 1)%2]);</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;                <span class="comment">// And the hanger-on now has no one to cling to</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;                connected_vrt_ids[ivrt].clear();</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;                ncv = 0;</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;              }</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;          }</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;          <span class="comment">// Gets evicted from the hosting face</span></div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;          face_unique_vrts[iface].erase(face_unique_vrts[iface].begin() + </div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                                        vrt_in_faces[ivrt][icf].second);</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;          <span class="comment">// Tell the following face vertices about their change of address</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifv = vrt_in_faces[ivrt][icf].second; </div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;                   ifv &lt; face_unique_vrts[iface].size(); ifv++) {</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;            <span class="keywordtype">int</span> icur_vrt = face_unique_vrts[iface][ifv];</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vrt_in_faces[icur_vrt].size(); i++)</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;              <span class="keywordflow">if</span> (vrt_in_faces[icur_vrt][i].first == iface) {</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;                vrt_in_faces[icur_vrt][i].second--;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;                <span class="keywordflow">break</span>;</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;              }</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;          }</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;        }      </div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;        <span class="keywordflow">if</span> (!third_wheel) dropped_connections = <span class="keyword">true</span>;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;      }</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    }</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;  } <span class="keywordflow">while</span> (dropped_connections);</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;  <span class="comment">// Filter out degenerate faces</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;  <span class="keywordtype">int</span> face_id = 0;</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;  <span class="keywordflow">while</span> (face_id &lt; face_unique_vrts.size()) {</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    <span class="comment">// Check if this face is still at least a triangle</span></div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;    <span class="keywordflow">if</span> (face_unique_vrts[face_id].size() &gt; 2) face_id++;</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;      <span class="comment">//Dispose of the degenerate face</span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;      face_unique_vrts.erase(face_unique_vrts.begin() + face_id);  </div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;    }</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;  }</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;  </div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;  <span class="comment">// Check if it managed to remain at least a tetrahedron</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  nfaces = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_unique_vrts.size());</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  <span class="keywordflow">if</span> (nfaces &lt; 4) <span class="keywordflow">return</span> fit_poly;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;  <span class="comment">// Only the surviving vertices get remembered</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  <span class="keywordflow">if</span> (!hanging_vrts_ids.empty()) {</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    std::vector&lt;int&gt; unique2fit_vrt_ids(nvrts, -1);</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;    std::vector&lt;Point3&gt; fit_vrts;</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    fit_vrts.reserve(nvrts - hanging_vrts_ids.size());</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;      <span class="comment">// Check if this point is still around</span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;      <span class="keywordflow">if</span> (std::find(hanging_vrts_ids.begin(), hanging_vrts_ids.end(), ivrt) ==</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;          hanging_vrts_ids.end()) {</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;          unique2fit_vrt_ids[ivrt] = fit_vrts.size();</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;          fit_vrts.push_back(unique_vrts[ivrt]);</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;      }</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;    }</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    unique_vrts = fit_vrts;  </div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    std::vector&lt; std::vector&lt;int&gt; &gt; pruned_faces(nfaces);</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++) {</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;      <span class="keywordtype">int</span> face_nverts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_unique_vrts[iface].size());</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;      pruned_faces[iface].resize(face_nverts);</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifv = 0; ifv &lt; face_nverts; ifv++) </div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        pruned_faces[iface][ifv] = unique2fit_vrt_ids[face_unique_vrts[iface][ifv]];</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    }</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    face_unique_vrts = pruned_faces;</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;  }</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;  <span class="comment">// And they lived happily ever after</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;  fit_poly.<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(unique_vrts, face_unique_vrts, dst_tol);</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  <span class="keywordflow">return</span> fit_poly;</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;}</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="keyword">inline</span></div><div class="line"><a name="l01158"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a06e9c97f69aeca40afb983ab4c229059"> 1158</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespaceTangram.html#a06e9c97f69aeca40afb983ab4c229059">point_inside_matpoly</a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> mat_poly,</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;                          <span class="keyword">const</span> <a class="code" href="classTangram_1_1Point.html">Point&lt;3&gt;</a>&amp; pt, </div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;                          <span class="keywordtype">double</span> <a class="code" href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">dst_tol</a>,</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                          <span class="keywordtype">bool</span> convex_poly) {</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;  std::vector&lt; MatPoly&lt;3&gt; &gt; convex_polys;</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;  <span class="keywordflow">if</span> (convex_poly)</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    convex_polys.push_back(mat_poly);</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;  <span class="keywordflow">else</span> </div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">facetize_decompose</a>(convex_polys);</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icp = 0; icp &lt; convex_polys.size(); icp++) {</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    <span class="keyword">const</span> std::vector&lt; Point&lt;3&gt; &gt;&amp; poly_pts = convex_polys[icp].points();</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    <span class="keywordtype">bool</span> pt_inside_cur_poly = <span class="keyword">true</span>;</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; convex_polys[icp].num_faces(); iface++) {</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;      <span class="keyword">const</span> std::vector&lt;int&gt;&amp; iface_vrts = convex_polys[icp].face_vertices(iface);</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;      <a class="code" href="classTangram_1_1Vector.html">Vector3</a> pt2vrt_vec;</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;      <span class="keywordtype">double</span> pt2vrt_dst = 0.0;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;      <span class="comment">//Find a face vertex that is the farthest from the given point</span></div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifvrt = 0; ifvrt &lt; iface_vrts.size(); ifvrt++) {</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;        <a class="code" href="classTangram_1_1Vector.html">Vector3</a> cur_pt2vrt_vec = </div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;          convex_polys[icp].vertex_point(iface_vrts[ifvrt]) - pt;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;        <span class="keywordtype">double</span> cur_vec_norm = cur_pt2vrt_vec.<a class="code" href="classTangram_1_1Vector.html#adaf9a2f1b36d0713d2ae772e5ecd3103">norm</a>();</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;        <span class="keywordflow">if</span> (cur_vec_norm &gt; pt2vrt_dst) {</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;          pt2vrt_vec = cur_pt2vrt_vec;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;          pt2vrt_dst = cur_vec_norm;</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;        }</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;      }</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;      pt2vrt_vec /= pt2vrt_dst;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;      <a class="code" href="classTangram_1_1Vector.html">Vector3</a> face_normal = <a class="code" href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">polygon3d_normal</a>(poly_pts, iface_vrts, dst_tol);</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;      <span class="keywordflow">if</span> (face_normal.<a class="code" href="classTangram_1_1Vector.html#a18e2941185b8227b1bcb1f460abb12bb">is_zero</a>(dst_tol))</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;      <span class="keywordtype">double</span> dist2plane = <a class="code" href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">dot</a>(pt2vrt_vec, face_normal);</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;      <span class="comment">//Check the signed distance to the plane</span></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;      <span class="keywordflow">if</span> (dist2plane &lt;= dst_tol) {</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;        pt_inside_cur_poly = <span class="keyword">false</span>;</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;      }</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    }  </div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;    <span class="keywordflow">if</span> (pt_inside_cur_poly)</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;  }</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;}</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;}  <span class="comment">// namespace Tangram</span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="preprocessor">#endif  // TANGRAM_MATPOLY_H_</span></div><div class="ttc" id="classTangram_1_1MatPoly_html_acc2a5d89ddc811f6acb3ef4d4780d753"><div class="ttname"><a href="classTangram_1_1MatPoly.html#acc2a5d89ddc811f6acb3ef4d4780d753">Tangram::MatPoly::MatPoly</a></div><div class="ttdeci">MatPoly(int const material_id=-1)</div><div class="ttdoc">Constructor, undefined material ID corresponds to -1 value. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:169</div></div>
<div class="ttc" id="namespaceTangram_html_a4a082d6df64712201cc18e4a3228eecc"><div class="ttname"><a href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">Tangram::cell_get_matpoly</a></div><div class="ttdeci">void cell_get_matpoly(const Mesh_Wrapper &amp;Mesh, const int cellid, MatPoly&lt; 2 &gt; *mat_poly, const double dst_tol)</div><div class="ttdoc">Initializes a material polygon that corresponds to (i.e. has the same geometry as) a given mesh cell...</div><div class="ttdef"><b>Definition:</b> MatPoly.h:762</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_abaf29e137ee4fa958dccc7fa7e7ea785"><div class="ttname"><a href="classTangram_1_1MatPoly.html#abaf29e137ee4fa958dccc7fa7e7ea785">Tangram::MatPoly::assign_moments</a></div><div class="ttdeci">void assign_moments(const std::vector&lt; double &gt; &amp;moments) const</div><div class="ttdoc">Assigns externally computed moments to this material poly. Can also be used to copy moments from the ...</div><div class="ttdef"><b>Definition:</b> MatPoly.h:354</div></div>
<div class="ttc" id="namespaceTangram_html_a0d7f6faf100a226eee664d64ef9f725a"><div class="ttname"><a href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Tangram::Point3</a></div><div class="ttdeci">Point&lt; 3 &gt; Point3</div><div class="ttdoc">Alias for creating a Point in 3d. </div><div class="ttdef"><b>Definition:</b> Point.h:187</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a3a65db5622231e4086244ad25ab6288d"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">Tangram::MatPoly::decompose</a></div><div class="ttdeci">void decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Decomposes this MatPoly into MatPoly&amp;#39;s using its centroid. If faces of MatPoly are planar...</div></div>
<div class="ttc" id="namespaceTangram_html_a06e9c97f69aeca40afb983ab4c229059"><div class="ttname"><a href="namespaceTangram.html#a06e9c97f69aeca40afb983ab4c229059">Tangram::point_inside_matpoly</a></div><div class="ttdeci">bool point_inside_matpoly(const MatPoly&lt; 3 &gt; mat_poly, const Point&lt; 3 &gt; &amp;pt, double dst_tol, bool convex_poly)</div><div class="ttdoc">Checks if a given point is interior wrt to a given polyhedron. Note: boundary points are no considere...</div><div class="ttdef"><b>Definition:</b> MatPoly.h:1158</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a8e814a40956aee6c5ade0c20abefe920"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">Tangram::MatPoly::facetize_decompose</a></div><div class="ttdeci">void facetize_decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Facetizes and decomposes this MatPoly into simplex MatPoly&amp;#39;s using its centroid. </div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a5d4e12c797bbbaae17e97908cecd5b24"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a5d4e12c797bbbaae17e97908cecd5b24">Tangram::MatPoly::face_points</a></div><div class="ttdeci">std::vector&lt; Point&lt; D &gt; &gt; face_points(int const face_id) const</div><div class="ttdoc">Coordinates of vertices of the material poly&amp;#39;s face. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:270</div></div>
<div class="ttc" id="classTangram_1_1Vector_html_a15d0c4cf8f5b7529f4e0895ab6e6c933"><div class="ttname"><a href="classTangram_1_1Vector.html#a15d0c4cf8f5b7529f4e0895ab6e6c933">Tangram::Vector::normalize</a></div><div class="ttdeci">void normalize()</div><div class="ttdoc">Convert this Vector into a unit Vector. </div><div class="ttdef"><b>Definition:</b> Vector.h:169</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a5f2c01d5edefa8331e146b12d0cc2f4e"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">Tangram::MatPoly::initialize</a></div><div class="ttdeci">void initialize(const std::vector&lt; Point2 &gt; &amp;poly_points, const double dst_tol)</div><div class="ttdoc">Initialize a 2D polygon from its vertices. </div></div>
<div class="ttc" id="namespaceTangram_html_a84b9705686c77f9e2022cf7cffb8435c"><div class="ttname"><a href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">Tangram::cross</a></div><div class="ttdeci">double cross(const Vector&lt; 2 &gt; &amp;a, const Vector&lt; 2 &gt; &amp;b)</div><div class="ttdoc">Cross product operator for two 2d vectors, . </div><div class="ttdef"><b>Definition:</b> Vector.h:279</div></div>
<div class="ttc" id="classTangram_1_1Vector_html"><div class="ttname"><a href="classTangram_1_1Vector.html">Tangram::Vector</a></div><div class="ttdoc">Represents a vector in N-dimensional space. </div><div class="ttdef"><b>Definition:</b> Vector.h:39</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa756cca3df1a498d170bc3a86e6bae7b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa756cca3df1a498d170bc3a86e6bae7b">Tangram::MatPoly::points</a></div><div class="ttdeci">const std::vector&lt; Point&lt; D &gt; &gt; &amp; points() const</div><div class="ttdoc">Points for all the vertices of the material poly. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:251</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a957d9a56af044a7ca917817467298d07"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a957d9a56af044a7ca917817467298d07">Tangram::MatPoly::moments</a></div><div class="ttdeci">const std::vector&lt; double &gt; &amp; moments() const</div><div class="ttdoc">Moments of material poly, when the method is called for the first time, moments will be computed and ...</div><div class="ttdef"><b>Definition:</b> MatPoly.h:341</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aab5cfa3fff9b96d2cbf96415fe7704af"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aab5cfa3fff9b96d2cbf96415fe7704af">Tangram::MatPoly::face_vertices</a></div><div class="ttdeci">const std::vector&lt; int &gt; &amp; face_vertices(int const face_id) const</div><div class="ttdoc">Indices of vertices of the material poly&amp;#39;s face. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:258</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a82d4a7bb4295c65916aaec1cc03b9a00"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a82d4a7bb4295c65916aaec1cc03b9a00">Tangram::MatPoly::num_faces</a></div><div class="ttdeci">int num_faces() const</div><div class="ttdoc">Number of material poly&amp;#39;s faces. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:333</div></div>
<div class="ttc" id="classTangram_1_1Vector_html_adaf9a2f1b36d0713d2ae772e5ecd3103"><div class="ttname"><a href="classTangram_1_1Vector.html#adaf9a2f1b36d0713d2ae772e5ecd3103">Tangram::Vector::norm</a></div><div class="ttdeci">double norm(bool doSqrt=true) const</div><div class="ttdoc">Calculate the norm of a Vector. </div><div class="ttdef"><b>Definition:</b> Vector.h:139</div></div>
<div class="ttc" id="namespaceTangram_html_a498a02ba72d13092913c9ac3d5a7f8b2"><div class="ttname"><a href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">Tangram::polygon3d_normal</a></div><div class="ttdeci">Vector&lt; 3 &gt; polygon3d_normal(const std::vector&lt; Point3 &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, double dst_tol)</div><div class="ttdef"><b>Definition:</b> MatPoly.h:118</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aff224788989415116c567aabc00f578b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aff224788989415116c567aabc00f578b">Tangram::MatPoly::bounding_box</a></div><div class="ttdeci">BoundingBox_t&lt; D &gt; bounding_box() const</div><div class="ttdef"><b>Definition:</b> MatPoly.h:390</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html"><div class="ttname"><a href="classTangram_1_1MatPoly.html">Tangram::MatPoly</a></div><div class="ttdef"><b>Definition:</b> MatPoly.h:163</div></div>
<div class="ttc" id="namespaceTangram_html_a69297ec3a4d9448be375b217d7297fe9"><div class="ttname"><a href="namespaceTangram.html#a69297ec3a4d9448be375b217d7297fe9">Tangram::natural_selection</a></div><div class="ttdeci">MatPoly&lt; 2 &gt; natural_selection(const std::vector&lt; Point&lt; 2 &gt; &gt; &amp;poly_points, const double dst_tol, const std::vector&lt; Point&lt; 2 &gt; &gt; *reference_pts=nullptr)</div><div class="ttdoc">Eliminates degenerate faces from a polygon given by a sequence of vertices. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:906</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a4de137538d76c83a6b56f71e6ac7a602"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a4de137538d76c83a6b56f71e6ac7a602">Tangram::MatPoly::set_mat_id</a></div><div class="ttdeci">void set_mat_id(int const mat_id)</div><div class="ttdoc">Set the ID of the material contained in this poly. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:198</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html_aeb5db1642a6d790563f1ae78154de428"><div class="ttname"><a href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">Tangram::Plane_t::normal</a></div><div class="ttdeci">Vector&lt; D &gt; normal</div><div class="ttdef"><b>Definition:</b> tangram.h:174</div></div>
<div class="ttc" id="classTangram_1_1Point_html"><div class="ttname"><a href="classTangram_1_1Point.html">Tangram::Point</a></div><div class="ttdoc">Represents a point in an N-dimensional space. </div><div class="ttdef"><b>Definition:</b> Point.h:48</div></div>
<div class="ttc" id="namespaceTangram_html"><div class="ttname"><a href="namespaceTangram.html">Tangram</a></div><div class="ttdef"><b>Definition:</b> CellMatPoly.h:18</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a1eefd7af6205b972c3a5821d846618c8"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a1eefd7af6205b972c3a5821d846618c8">Tangram::MatPoly::compute_moments</a></div><div class="ttdeci">void compute_moments(std::vector&lt; double &gt; &amp;moments) const</div><div class="ttdoc">Computes moments of this material poly. </div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_ab6cf600e68b2ac811f7d53abff3c741f"><div class="ttname"><a href="classTangram_1_1MatPoly.html#ab6cf600e68b2ac811f7d53abff3c741f">Tangram::MatPoly::face_centroid</a></div><div class="ttdeci">Point&lt; D &gt; face_centroid(int const face_id) const</div><div class="ttdoc">Coordinates of the centroid of the material poly&amp;#39;s face. </div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_afc22b40e580e13e26e8aeec7f089c354"><div class="ttname"><a href="classTangram_1_1MatPoly.html#afc22b40e580e13e26e8aeec7f089c354">Tangram::MatPoly::dst_tol</a></div><div class="ttdeci">double dst_tol() const</div><div class="ttdoc">Distance tolerance used by this poly. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:245</div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html">Tangram::BoundingBox_t</a></div><div class="ttdef"><b>Definition:</b> tangram.h:232</div></div>
<div class="ttc" id="tangram_8h_html"><div class="ttname"><a href="tangram_8h.html">tangram.h</a></div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html_a0de6ac6eb2b34ebc3d70ced8df621ce5"><div class="ttname"><a href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">Tangram::Plane_t::dist2origin</a></div><div class="ttdeci">double dist2origin</div><div class="ttdef"><b>Definition:</b> tangram.h:175</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a860f132a1987d539089fc1c80c7404a7"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">Tangram::MatPoly::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Resets the MatPoly data. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:213</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html"><div class="ttname"><a href="structTangram_1_1Plane__t.html">Tangram::Plane_t</a></div><div class="ttdef"><b>Definition:</b> tangram.h:173</div></div>
<div class="ttc" id="namespaceTangram_html_a3f3b5ab00373f6e544350802fc83ba88"><div class="ttname"><a href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">Tangram::dot</a></div><div class="ttdeci">double dot(const Vector&lt; D &gt; &amp;a, const Vector&lt; D &gt; &amp;b)</div><div class="ttdoc">Dot product of two vectors, . </div><div class="ttdef"><b>Definition:</b> Vector.h:223</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_ace8b5fde89a513f0e9467f3ce8796e50"><div class="ttname"><a href="classTangram_1_1MatPoly.html#ace8b5fde89a513f0e9467f3ce8796e50">Tangram::MatPoly::mat_id</a></div><div class="ttdeci">int mat_id() const</div><div class="ttdoc">ID of the material this poly contains. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:192</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa5681ccd23930482bb6b3c243fb4425c"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">Tangram::MatPoly::faceted_matpoly</a></div><div class="ttdeci">void faceted_matpoly(MatPoly&lt; 2 &gt; *faceted_poly) const</div><div class="ttdoc">Facetization of the 2D polygon&amp;#39;s boundary: simply creates a copy of the polygon. </div></div>
<div class="ttc" id="namespaceTangram_html_add95776fd9a423b220c590e28f32fd22"><div class="ttname"><a href="namespaceTangram.html#add95776fd9a423b220c590e28f32fd22">Tangram::polygon3d_area</a></div><div class="ttdeci">double polygon3d_area(const std::vector&lt; Point3 &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, double dst_tol)</div><div class="ttdef"><b>Definition:</b> MatPoly.h:20</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_ac6c290557b576c6aad5051d57a5b5685"><div class="ttname"><a href="classTangram_1_1MatPoly.html#ac6c290557b576c6aad5051d57a5b5685">Tangram::MatPoly::vertex_point</a></div><div class="ttdeci">Point&lt; D &gt; vertex_point(int const vertex_id) const</div><div class="ttdoc">Coordinates of the material poly&amp;#39;s vertex. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:296</div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html_ad4ae706e0bc47e7416cfb1dc2d12d3db"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">Tangram::BoundingBox_t::max</a></div><div class="ttdeci">double max[D]</div><div class="ttdef"><b>Definition:</b> tangram.h:234</div></div>
<div class="ttc" id="classTangram_1_1Vector_html_a18e2941185b8227b1bcb1f460abb12bb"><div class="ttname"><a href="classTangram_1_1Vector.html#a18e2941185b8227b1bcb1f460abb12bb">Tangram::Vector::is_zero</a></div><div class="ttdeci">bool is_zero() const</div><div class="ttdoc">Check if this Vector is a zero Vector. </div><div class="ttdef"><b>Definition:</b> Vector.h:180</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aba885f75525c109661a08cb41a413a5b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">Tangram::MatPoly::face_planes</a></div><div class="ttdeci">void face_planes(std::vector&lt; Plane_t&lt; D &gt; &gt; &amp;fplanes) const</div><div class="ttdoc">For every face, returns a plane containing that face. Important: faces should be planar, so you might need to facetize the MatPoly first. In 2D, faces of size below the distance tolerance will be omitted. In 3D, faces should have at least three edges of size above the distance tolerance. If the number of valid planes is less than four, empty vector will be returned. </div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_acf9b8b3197a7b4dd7089042843020fa3"><div class="ttname"><a href="classTangram_1_1MatPoly.html#acf9b8b3197a7b4dd7089042843020fa3">Tangram::MatPoly::~MatPoly</a></div><div class="ttdeci">~MatPoly()</div><div class="ttdef"><b>Definition:</b> MatPoly.h:172</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aac14f299f075ed1688c24103e1b268ac"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aac14f299f075ed1688c24103e1b268ac">Tangram::MatPoly::operator=</a></div><div class="ttdeci">MatPoly &amp; operator=(const MatPoly &amp;source_poly)</div><div class="ttdoc">Assignment operator. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:178</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_affd023482f50eeae0d97c7fa6697e358"><div class="ttname"><a href="classTangram_1_1MatPoly.html#affd023482f50eeae0d97c7fa6697e358">Tangram::MatPoly::face_vertices</a></div><div class="ttdeci">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; face_vertices() const</div><div class="ttdoc">All indices of vertices of the material poly&amp;#39;s faces. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:287</div></div>
<div class="ttc" id="namespaceTangram_html_aa0379ce04695d2beacee8173ab40f62b"><div class="ttname"><a href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">Tangram::polygon3d_moments</a></div><div class="ttdeci">void polygon3d_moments(const std::vector&lt; Point3 &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, std::vector&lt; double &gt; &amp;poly_moments, double dst_tol)</div><div class="ttdef"><b>Definition:</b> MatPoly.h:64</div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html_ab255aa2370f495b3c8b00f2a92ea72b0"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">Tangram::BoundingBox_t::min</a></div><div class="ttdeci">double min[D]</div><div class="ttdef"><b>Definition:</b> tangram.h:233</div></div>
<div class="ttc" id="namespaceTangram_html_a71c39deca72d48990415ee231a9170b1"><div class="ttname"><a href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">Tangram::vector</a></div><div class="ttdeci">std::vector&lt; T &gt; vector</div><div class="ttdef"><b>Definition:</b> tangram.h:138</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa32646522284f28e04aad59e815542f1"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa32646522284f28e04aad59e815542f1">Tangram::MatPoly::num_vertices</a></div><div class="ttdeci">int num_vertices() const</div><div class="ttdoc">Number of material poly&amp;#39;s vertices. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:328</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a4ffd8855a46fd704ce7749d43f8ded4e"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a4ffd8855a46fd704ce7749d43f8ded4e">Tangram::MatPoly::reset_mat_id</a></div><div class="ttdeci">void reset_mat_id()</div><div class="ttdoc">Set the material ID for this poly to the undefined state. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:208</div></div>
</div><!-- fragment --></div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
