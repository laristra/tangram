<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>tangram: /home/portage/tangram/tangram/intersect/split_r3d.h Source File</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_043c38e9c2239d2104f02eee845ed8d8.html">tangram</a></li><li class="navelem"><a class="el" href="dir_ac67a70d9b607d82a33b1de4ed29653f.html">intersect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">split_r3d.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="split__r3d_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> This file is part of the Ristra tangram project.</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> Please see the license file at the root of this repository, or at:</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> https://github.com/laristra/tangram/blob/master/LICENSE</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#ifndef TANGRAM_INTERSECT_SPLIT_R3D_H_</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#define TANGRAM_INTERSECT_SPLIT_R3D_H_</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// tangram includes</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;wonton/intersect/r3d/r3d.h&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="tangram_8h.html">tangram/support/tangram.h</a>&quot;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="MatPoly_8h.html">tangram/support/MatPoly.h</a>&quot;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceTangram.html">Tangram</a> {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="keywordtype">void</span></div><div class="line"><a name="l00042"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">   42</a></span>&#160;<a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">matpoly_to_r3dpoly</a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>&amp; mat_poly,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                   <a class="code" href="structr3d__poly.html">r3d_poly</a>&amp; r3dpoly) {</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <span class="comment">//Translate coordinates of vertices to R3D format</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="keyword">const</span> std::vector&lt;Point3&gt;&amp; matpoly_vrts = mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#aa756cca3df1a498d170bc3a86e6bae7b">points</a>();</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <span class="keywordtype">int</span> nvrts = mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#aa32646522284f28e04aad59e815542f1">num_vertices</a>();</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <a class="code" href="unionr3d__rvec3.html">r3d_rvec3</a>* r3dized_poly_vrts;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  r3dized_poly_vrts = <span class="keyword">new</span> <a class="code" href="unionr3d__rvec3.html">r3d_rvec3</a> [nvrts];</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++)</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;      r3dized_poly_vrts[ivrt].xyz[ixyz] = matpoly_vrts[ivrt][ixyz];</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="comment">//Get faces of the polyhedron in terms of local indices of its vertices</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <span class="keywordtype">int</span> nfaces = mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a82d4a7bb4295c65916aaec1cc03b9a00">num_faces</a>();</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>* nface_vrts;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  nface_vrts = <span class="keyword">new</span> <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a> [nfaces];</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>** r3dized_poly_faces;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  r3dized_poly_faces = <span class="keyword">new</span> <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>* [nfaces];</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++) {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keyword">const</span> std::vector&lt;int&gt;&amp; matpoly_faces = mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#aab5cfa3fff9b96d2cbf96415fe7704af">face_vertices</a>(iface);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordtype">int</span> face_nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(matpoly_faces.size());</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    nface_vrts[iface] = face_nvrts;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    r3dized_poly_faces[iface] = <span class="keyword">new</span> <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a> [face_nvrts];</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; face_nvrts; ivrt++)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      r3dized_poly_faces[iface][ivrt] = matpoly_faces[ivrt];</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  }</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  </div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <a class="code" href="r3d_8h.html#afcba1d5250f023c0ad724b26f75f7252">r3d_init_poly</a>(&amp;r3dpoly, r3dized_poly_vrts, nvrts, r3dized_poly_faces, nface_vrts, nfaces);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  </div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <span class="keyword">delete</span> [] r3dized_poly_vrts;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  <span class="keyword">delete</span> [] nface_vrts;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keyword">delete</span> [] r3dized_poly_faces[iface];</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="keyword">delete</span> [] r3dized_poly_faces;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="keywordtype">void</span></div><div class="line"><a name="l00085"></a><span class="lineno"><a class="line" href="namespaceTangram.html#ad21544d74adf6c81745e56cb8a2d4a41">   85</a></span>&#160;<a class="code" href="namespaceTangram.html#ad21544d74adf6c81745e56cb8a2d4a41">r3dpoly_to_matpolys</a>(<span class="keyword">const</span> <a class="code" href="structr3d__poly.html">r3d_poly</a>&amp; r3dpoly,</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                    <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> &gt;&amp; mat_polys) {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  <a class="code" href="structr3d__brep.html">r3d_brep</a>* poly_brep;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a> ncomponents;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <a class="code" href="structr3d__poly.html">r3d_poly</a> poly_copy = r3dpoly;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <a class="code" href="r3d_8h.html#a4e35e1242db9a7738a98bbf423962b51">r3d_init_brep</a>(&amp;poly_copy, &amp;poly_brep, &amp;ncomponents);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  mat_polys.clear();</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="keywordflow">if</span> (ncomponents == 0) {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <a class="code" href="r3d_8h.html#a1185134e293f53b23a45bae8543edbd1">r3d_free_brep</a>(&amp;poly_brep, 0);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  }</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  mat_polys.reserve(ncomponents);</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncomponents; ipoly++) {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordtype">int</span> nvrts = poly_brep[ipoly].<a class="code" href="structr3d__brep.html#a1112473427a084ceeecbc603dbeaf65a">numvertices</a>;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    std::vector&lt;Point3&gt; curpoly_vrts;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    curpoly_vrts.reserve(nvrts);</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// We only store unique vertices, so we need a map from r3d node indices</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="comment">// to MatPoly node indices for when we process faces</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    std::vector&lt;int&gt; r3d2matpoly_vrt_ids(nvrts, -1);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;      <a class="code" href="classTangram_1_1Point.html">Point3</a> cur_vrt;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        cur_vrt[ixyz] = poly_brep[ipoly].vertices[ivrt].xyz[ixyz];</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      <span class="comment">// Check if this point is already stored</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; curpoly_vrts.size(); i++)</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="comment">//Points are considered equivalent if all their respective coordinates </span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="comment">//are within machine epsilon from each other</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        <span class="keywordflow">if</span> (cur_vrt == curpoly_vrts[i]) {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;          r3d2matpoly_vrt_ids[ivrt] = i;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <span class="comment">// If the point is unique, we store it</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="keywordflow">if</span> (r3d2matpoly_vrt_ids[ivrt] == -1) {</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        r3d2matpoly_vrt_ids[ivrt] = curpoly_vrts.size();</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        curpoly_vrts.push_back(cur_vrt);</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    curpoly_vrts.shrink_to_fit();</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">if</span> (curpoly_vrts.size() &lt; 4) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="keywordtype">int</span> nfaces = poly_brep[ipoly].<a class="code" href="structr3d__brep.html#ada56a04094fa2bdd74ff9085dbb7a85c">numfaces</a>;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    std::vector&lt; std::vector&lt;int&gt; &gt; curpoly_faces(nfaces);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++) {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;      <span class="keywordtype">int</span> face_nverts = poly_brep[ipoly].<a class="code" href="structr3d__brep.html#aafbf7bf0fe6d1d40eda771d747e1a985">numvertsperface</a>[iface];</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifv = 0; ifv &lt; face_nverts; ifv++) {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordtype">int</span> cur_vrt_id = r3d2matpoly_vrt_ids[poly_brep[ipoly].<a class="code" href="structr3d__brep.html#adaa9649c626cb6f0e1959eeac9617520">faceinds</a>[iface][ifv]];</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="comment">// We only add unique node indices to the list of face&#39;s nodes</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">if</span> (std::find(curpoly_faces[iface].begin(), curpoly_faces[iface].end(), </div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                      cur_vrt_id) == curpoly_faces[iface].end())</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;          curpoly_faces[iface].push_back(cur_vrt_id);</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    std::vector&lt;int&gt; hanging_nodes;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="keywordtype">bool</span> removed_nodes = <span class="keyword">true</span>;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="keywordflow">while</span> (removed_nodes) {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      <span class="comment">//Removing nodes can result in new degenerate faces, so keep removing</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      <span class="comment">//such faces until no hanging nodes are left</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      removed_nodes = <span class="keyword">false</span>;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="comment">// Filter out degenerate faces</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      <span class="keywordtype">int</span> ind_face = 0;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <span class="keywordflow">while</span> (ind_face &lt; curpoly_faces.size())</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">if</span> (curpoly_faces[ind_face].size() &gt; 2) ind_face++;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          <span class="comment">//A degenerate face can collapse into a hanging point on an edge, i.e.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;          <span class="comment">//a node that is connected to less than three other nodes.</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;          <span class="comment">//We eliminate such nodes from faces: converting a polyhedron that has</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          <span class="comment">//hanging nodes using r3d_init_poly can result in an r3d_poly</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;          <span class="comment">//with no vertices</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifn = 0; ifn &lt; curpoly_faces[ind_face].size(); ifn++) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            <span class="keywordtype">int</span> inode = curpoly_faces[ind_face][ifn];</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            std::vector&lt;int&gt; iconnected_nodes;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            std::vector&lt;std::pair&lt;int,int&gt;&gt; node_in_faces;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; curpoly_faces.size(); iface++) {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;              <span class="keywordtype">int</span> in_face_id = std::distance(curpoly_faces[iface].begin(),</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;                                             std::find(curpoly_faces[iface].begin(),</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                                       curpoly_faces[iface].end(), inode));</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;              <span class="keywordtype">int</span> nface_vrts = curpoly_faces[iface].size();</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;              <span class="keywordflow">if</span> (in_face_id != nface_vrts) {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;                <span class="comment">//Node of a degenerate face is also a node of the current face</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                node_in_faces.push_back(std::pair&lt;int,int&gt;(iface, in_face_id));</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="comment">//We look for unique adjacent nodes in the current face</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p0n1 = 0; p0n1 &lt; 2; p0n1++) {</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                  <span class="keywordtype">int</span> adj_node_face_id = (nface_vrts + in_face_id + 2*p0n1 - 1)%nface_vrts;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                  <span class="keywordflow">if</span> (std::find(iconnected_nodes.begin(), iconnected_nodes.end(),</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                                curpoly_faces[iface][adj_node_face_id]) == iconnected_nodes.end())</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;                    iconnected_nodes.push_back(curpoly_faces[iface][adj_node_face_id]);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;              }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            }  </div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="comment">//Check if the current face node is a hanging node, if so, remove it</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;            <span class="keywordflow">if</span> (iconnected_nodes.size() &lt; 3) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;              removed_nodes = <span class="keyword">true</span>;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;              hanging_nodes.push_back(inode);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icf = 0; icf &lt; node_in_faces.size(); icf++) {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                <span class="keywordtype">int</span> iface = node_in_faces[icf].first;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                curpoly_faces[iface].erase(curpoly_faces[iface].begin() + </div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                           node_in_faces[icf].second);</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;              }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            }</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;          }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;          <span class="comment">//Now, remove the degenerate face</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;          curpoly_faces.erase(curpoly_faces.begin() + ind_face);  </div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        }</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    }</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="comment">//We remove nodes no longer present in the poly: passing to r3d_init_poly</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="comment">//vertices that are not used by any faces can result in an empty r3d_poly</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keywordflow">if</span> (!hanging_nodes.empty()) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      nvrts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(curpoly_vrts.size());</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      std::vector&lt;int&gt; old2new_vrt_ids(nvrts, -1);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      std::vector&lt;Point3&gt; shrunk_vrts;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      shrunk_vrts.reserve(nvrts - hanging_nodes.size());</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; nvrts; ivrt++) {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="comment">// Check if this point was removed</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keywordflow">if</span> (std::find(hanging_nodes.begin(), hanging_nodes.end(), ivrt) ==</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            hanging_nodes.end()) {</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            old2new_vrt_ids[ivrt] = shrunk_vrts.size();</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            shrunk_vrts.push_back(curpoly_vrts[ivrt]);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        }</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      curpoly_vrts = shrunk_vrts;  </div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      nfaces = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(curpoly_faces.size());</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      std::vector&lt; std::vector&lt;int&gt; &gt; updated_faces(nfaces);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iface = 0; iface &lt; nfaces; iface++) {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordtype">int</span> face_nverts = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(curpoly_faces[iface].size());</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        updated_faces[iface].resize(face_nverts);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ifv = 0; ifv &lt; face_nverts; ifv++) </div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;          updated_faces[iface][ifv] = old2new_vrt_ids[curpoly_faces[iface][ifv]];</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      curpoly_faces = updated_faces;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">// We do not store polyhedra with less than four faces, </span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="comment">// as they are clearly degenerate</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">if</span> (curpoly_faces.size() &gt; 3) {</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      <span class="keywordtype">int</span> inew_poly = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(mat_polys.size());</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      mat_polys.push_back(<a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>());</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      mat_polys[inew_poly].initialize(curpoly_vrts, curpoly_faces);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  }</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  mat_polys.shrink_to_fit();</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  <a class="code" href="r3d_8h.html#a1185134e293f53b23a45bae8543edbd1">r3d_free_brep</a>(&amp;poly_brep, ncomponents);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="keywordtype">void</span></div><div class="line"><a name="l00246"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a3b33cbabca7f3d25bf3a39d72909f1be">  246</a></span>&#160;<a class="code" href="namespaceTangram.html#a3b33cbabca7f3d25bf3a39d72909f1be">split_convex_matpoly_r3d</a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>&amp; mat_poly,</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                         <span class="keyword">const</span> <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a>&amp; cutting_plane,</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                         <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>&amp; lower_halfspace_poly,</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                         <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>&amp; upper_halfspace_poly,</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                         std::vector&lt;double&gt;&amp; lower_halfspace_moments,</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                         std::vector&lt;double&gt;&amp; upper_halfspace_moments) {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">//Translate the cutting plane to R3D format</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <a class="code" href="structr3d__plane.html">r3d_plane</a> r3d_cut_plane;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    r3d_cut_plane.<a class="code" href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">n</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[ixyz] = cutting_plane.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>[ixyz];</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  r3d_cut_plane.<a class="code" href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">d</a> = cutting_plane.<a class="code" href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">dist2origin</a>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <a class="code" href="structr3d__poly.html">r3d_poly</a> r3dized_poly;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <a class="code" href="structr3d__poly.html">r3d_poly</a> r3d_subpolys[2];</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">matpoly_to_r3dpoly</a>(mat_poly, r3dized_poly);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <a class="code" href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a>(&amp;r3dized_poly, 1, r3d_cut_plane, &amp;r3d_subpolys[1], &amp;r3d_subpolys[0]);</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>* subpoly_ptrs[2] = {&amp;lower_halfspace_poly, &amp;upper_halfspace_poly};</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  std::vector&lt;double&gt;* subpoly_moments_ptrs[2] = {&amp;lower_halfspace_moments, </div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                                  &amp;upper_halfspace_moments};</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> isp = 0; isp &lt; 2; isp++) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="comment">//Check if the subpoly is empty</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span> (r3d_subpolys[isp].nverts == 0) {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      subpoly_ptrs[isp]-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">clear</a>();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      subpoly_moments_ptrs[isp]-&gt;clear();</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    }</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="comment">//Find the moments for a subpoly</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;r3d_subpolys[isp], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">if</span> (r3d_moments[0] &lt;= std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      subpoly_ptrs[isp]-&gt;<a class="code" href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">clear</a>();</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      subpoly_moments_ptrs[isp]-&gt;clear();</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    }    </div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    subpoly_moments_ptrs[isp]-&gt;assign(r3d_moments, r3d_moments + 4);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">//Get a MatPoly for a subpoly</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    std::vector&lt; MatPoly&lt;3&gt; &gt; sub_matpoly;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <a class="code" href="namespaceTangram.html#ad21544d74adf6c81745e56cb8a2d4a41">r3dpoly_to_matpolys</a>(r3d_subpolys[isp], sub_matpoly);</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordtype">int</span> ncomponents = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(sub_matpoly.size());</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">if</span> (ncomponents &gt; 1) {</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      <span class="comment">// Filter out degenerate components</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <span class="keywordtype">int</span> ind_subpoly = 0;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      <span class="keywordflow">while</span> (ind_subpoly &lt; sub_matpoly.size())</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">if</span> (sub_matpoly[ind_subpoly].moments()[0] &gt; </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            std::numeric_limits&lt;double&gt;::epsilon()) ind_subpoly++;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <span class="keywordflow">else</span> sub_matpoly.erase(sub_matpoly.begin() + ind_subpoly);  </div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    }</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      </div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">if</span> (ncomponents == 1) </div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;      *subpoly_ptrs[isp] = sub_matpoly[0];</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Non-convex MatPoly is split using the method for convex MatPoly&#39;s!&quot;</span>);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  }  </div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;}</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno"><a class="line" href="classTangram_1_1SplitR3D.html">  320</a></span>&#160;<span class="keyword">class </span><a class="code" href="classTangram_1_1SplitR3D.html">SplitR3D</a> {</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160; <span class="keyword">public</span>:</div><div class="line"><a name="l00322"></a><span class="lineno"><a class="line" href="classTangram_1_1SplitR3D.html#ab450a03d544623c8dc7e63799489d678">  322</a></span>&#160;  <a class="code" href="classTangram_1_1SplitR3D.html#ab450a03d544623c8dc7e63799489d678">SplitR3D</a>(<span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> &gt;&amp; matpolys,</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;           <span class="keyword">const</span> <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a>&amp; cutting_plane, </div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;           <span class="keyword">const</span> <span class="keywordtype">bool</span> all_convex = <span class="keyword">false</span>) : </div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;           matpolys_(matpolys), </div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;           cutting_plane_(cutting_plane),</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;           all_convex_(all_convex) {}</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno"><a class="line" href="classTangram_1_1SplitR3D.html#a7ed232832fa1fcce72d05cf2e0e33e27">  334</a></span>&#160;  <a class="code" href="structTangram_1_1HalfSpaceSets__t.html">HalfSpaceSets_t&lt;3&gt;</a> <a class="code" href="classTangram_1_1SplitR3D.html#a7ed232832fa1fcce72d05cf2e0e33e27">operator() </a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <a class="code" href="structTangram_1_1HalfSpaceSets__t.html">HalfSpaceSets_t&lt;3&gt;</a> hs_sets;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    std::vector&lt; MatPoly&lt;3&gt; &gt;* hs_subpolys_ptrs[2] = {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;      &amp;hs_sets.<a class="code" href="structTangram_1_1HalfSpaceSets__t.html#add9a75f9a740f31c1d57305349170690">lower_halfspace_set</a>.matpolys, &amp;hs_sets.<a class="code" href="structTangram_1_1HalfSpaceSets__t.html#a0aaef7e80ff5bcea881e7cacde2a4ab2">upper_halfspace_set</a>.matpolys};</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    std::vector&lt;double&gt;* hs_moments_ptrs[2] = {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;      &amp;hs_sets.<a class="code" href="structTangram_1_1HalfSpaceSets__t.html#add9a75f9a740f31c1d57305349170690">lower_halfspace_set</a>.moments, &amp;hs_sets.<a class="code" href="structTangram_1_1HalfSpaceSets__t.html#a0aaef7e80ff5bcea881e7cacde2a4ab2">upper_halfspace_set</a>.moments}; </div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    std::vector&lt; MatPoly&lt;3&gt; &gt; convex_components;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keyword">const</span> std::vector&lt; MatPoly&lt;3&gt; &gt;* convex_polys;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">if</span> (all_convex_)</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      convex_polys = &amp;matpolys_;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      <span class="keywordtype">int</span> nncpolys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(matpolys_.size());</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> incp = 0; incp &lt; nncpolys; incp++)</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        matpolys_[incp].decompose(convex_components);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;      convex_polys = &amp;convex_components;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ihs = 0; ihs &lt; 2; ihs++)</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      hs_moments_ptrs[ihs]-&gt;assign(4, 0.0);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordtype">int</span> hs_poly_count[2] = {0, 0};</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordtype">int</span> npolys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(convex_polys-&gt;size());</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icp = 0; icp &lt; npolys; icp++) {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> cur_subpolys[2];</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      std::vector&lt;double&gt; cur_moments[2];</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <a class="code" href="namespaceTangram.html#a3b33cbabca7f3d25bf3a39d72909f1be">split_convex_matpoly_r3d</a>((*convex_polys)[icp], cutting_plane_,</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                               cur_subpolys[0], cur_subpolys[1],</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                               cur_moments[0], cur_moments[1]);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ihs = 0; ihs &lt; 2; ihs++)</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="keywordflow">if</span> (!cur_moments[ihs].empty()) {</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          hs_subpolys_ptrs[ihs]-&gt;emplace_back(cur_subpolys[ihs]);</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; 4; im++)</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            (*hs_moments_ptrs[ihs])[im] += cur_moments[ihs][im];</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;          hs_poly_count[ihs]++;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        }</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    }</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ihs = 0; ihs &lt; 2; ihs++)</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      <span class="keywordflow">if</span> (hs_poly_count[ihs] == 0)</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        hs_moments_ptrs[ihs]-&gt;clear();</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> hs_sets;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <a class="code" href="classTangram_1_1SplitR3D.html#a50460daa5a59221d09431b9ee40fce01">SplitR3D</a>() = <span class="keyword">delete</span>;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <a class="code" href="classTangram_1_1SplitR3D.html">SplitR3D</a>&amp; <a class="code" href="classTangram_1_1SplitR3D.html#a42f491427bb8d9849d9f8a9ba528fe0b">operator = </a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1SplitR3D.html">SplitR3D</a>&amp;) = <span class="keyword">delete</span>;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160; <span class="keyword">private</span>:</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <span class="keyword">const</span> std::vector&lt; MatPoly&lt;3&gt; &gt;&amp; matpolys_;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  <span class="keyword">const</span> <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a>&amp; cutting_plane_;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  <span class="keywordtype">bool</span> all_convex_;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;};</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html">  412</a></span>&#160;<span class="keyword">class </span><a class="code" href="classTangram_1_1ClipR3D.html">ClipR3D</a> {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160; <span class="keyword">public</span>:</div><div class="line"><a name="l00414"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html#a81795b3025d7cd0861e1b219195f8826">  414</a></span>&#160;  <a class="code" href="classTangram_1_1ClipR3D.html#a81795b3025d7cd0861e1b219195f8826">ClipR3D</a>() {}</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html#a7eb95743fffdde2e24493f7086a25c06">  420</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1ClipR3D.html#a7eb95743fffdde2e24493f7086a25c06">set_plane</a>(<span class="keyword">const</span> <a class="code" href="structTangram_1_1Plane__t.html">Plane_t&lt;3&gt;</a>&amp; cutting_plane) {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      r3d_cut_plane_.n.xyz[ixyz] = -cutting_plane.<a class="code" href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">normal</a>[ixyz];</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    r3d_cut_plane_.d = -cutting_plane.<a class="code" href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">dist2origin</a>;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html#a03f40eaf0c37b20926cd90923efe93ac">  432</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classTangram_1_1ClipR3D.html#a03f40eaf0c37b20926cd90923efe93ac">set_matpolys</a>(<span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> &gt;&amp; matpolys,</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">bool</span> planar_faces = <span class="keyword">false</span>) {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="keywordtype">int</span> npolys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(matpolys.size());</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    r3d_polys_.resize(npolys);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordflow">if</span> (planar_faces) {</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; npolys; ipoly++)</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;        <a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">matpoly_to_r3dpoly</a>(matpolys[ipoly], r3d_polys_[ipoly]);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    }</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; npolys; ipoly++) {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a> faceted_poly;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        matpolys[ipoly].<a class="code" href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">faceted_matpoly</a>(&amp;faceted_poly);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">matpoly_to_r3dpoly</a>(faceted_poly, r3d_polys_[ipoly]);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      }</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  }</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html#a889c4f4815e82cf3d668249c9f58c025">  454</a></span>&#160;  std::vector&lt;double&gt; <a class="code" href="classTangram_1_1ClipR3D.html#a889c4f4815e82cf3d668249c9f58c025">aggregated_moments</a>() {</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    std::vector&lt;double&gt; agg_moments;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">if</span> (!r3d_polys_.empty()) {</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      agg_moments.assign(4, 0.0);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; r3d_polys_.size(); ipoly++) {</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordflow">if</span> (r3d_polys_[ipoly].nverts != 0) {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;          <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;r3d_polys_[ipoly], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;          <span class="keywordflow">if</span> (r3d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon())</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; 4; im++)</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;              agg_moments[im] += r3d_moments[im];</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        }</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;      }</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    }</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordflow">return</span> agg_moments;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  }</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno"><a class="line" href="classTangram_1_1ClipR3D.html#a41dbf51fa4e5601eb326e30028716090">  480</a></span>&#160;  std::vector&lt;double&gt; <a class="code" href="classTangram_1_1SplitR3D.html#a7ed232832fa1fcce72d05cf2e0e33e27">operator() </a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    std::vector&lt;double&gt; below_plane_moments(4, 0.0);</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordtype">int</span> poly_counter = 0;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; r3d_polys_.size(); ipoly++) {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;      <span class="keywordflow">if</span> (r3d_polys_[ipoly].nverts != 0) {</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="comment">//r3d does in-place clipping and does not have the const modifier</span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        <span class="comment">//for the plane: we need to make copies</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <a class="code" href="structr3d__poly.html">r3d_poly</a> clipped_poly = r3d_polys_[ipoly];</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        <a class="code" href="structr3d__plane.html">r3d_plane</a> plane_copy = r3d_cut_plane_;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        <a class="code" href="r3d_8h.html#ab3f21c5ada02190326fbe535032bfbe0">r3d_clip</a>(&amp;clipped_poly, &amp;plane_copy, 1);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        <span class="keywordflow">if</span> (clipped_poly.<a class="code" href="structr3d__poly.html#a49cb139c24b05f1ce30bc385f6938b50">nverts</a> != 0) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;          <span class="comment">//Find the moments for the part in the lower halfspace</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;          <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;clipped_poly, r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;          <span class="keywordflow">if</span> (r3d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; 4; im++)</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;              below_plane_moments[im] += r3d_moments[im];</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            poly_counter++;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;          }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        }</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      }</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    }</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    </div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="keywordflow">if</span> (poly_counter == 0)</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      below_plane_moments.clear();</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;      </div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keywordflow">return</span> below_plane_moments;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;  }</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;  <a class="code" href="classTangram_1_1ClipR3D.html">ClipR3D</a>&amp; <a class="code" href="classTangram_1_1SplitR3D.html#a42f491427bb8d9849d9f8a9ba528fe0b">operator = </a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1ClipR3D.html">ClipR3D</a>&amp;) = <span class="keyword">delete</span>;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; <span class="keyword">private</span>:</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  std::vector&lt;r3d_poly&gt; r3d_polys_;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  <a class="code" href="structr3d__plane.html">r3d_plane</a> r3d_cut_plane_;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;};</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno"><a class="line" href="namespaceTangram.html#ad580bc2bc65a62b3650d30447117732a">  543</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespaceTangram.html#af02fba4de7b9b6cdae6e0f7b655d96b9">get_intersection_moments</a>(<span class="keyword">const</span> <a class="code" href="classTangram_1_1MatPoly.html">MatPoly&lt;3&gt;</a>&amp; mat_poly,</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                              <span class="keyword">const</span> <a class="code" href="structr3d__poly.html">r3d_poly</a>&amp; r3dpoly,</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                              std::vector&lt;double&gt;&amp; intersection_moments,</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                              <span class="keywordtype">bool</span> convex_matpoly = <span class="keyword">false</span>) {   </div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="keywordflow">if</span> (convex_matpoly) {                                </div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    std::vector&lt; Plane_t&lt;3&gt; &gt; face_planes;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">face_planes</a>(face_planes);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a> intersection = r3dpoly;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordtype">int</span> nplanes = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_planes.size());</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <a class="code" href="structr3d__plane.html">r3d_plane</a>* r3d_face_planes = <span class="keyword">new</span> <a class="code" href="structr3d__plane.html">r3d_plane</a> [nplanes];</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iplane = 0; iplane &lt; nplanes; iplane++) {</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        r3d_face_planes[iplane].n.xyz[ixyz] = -face_planes[iplane].normal[ixyz];</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;      r3d_face_planes[iplane].<a class="code" href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">d</a> = -face_planes[iplane].dist2origin;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;    <a class="code" href="r3d_8h.html#ab3f21c5ada02190326fbe535032bfbe0">r3d_clip</a>(&amp;intersection, r3d_face_planes, (<a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>) nplanes);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    </div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    <span class="keyword">delete</span> [] r3d_face_planes;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;intersection, r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    intersection_moments.resize(4);</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; 4; im++)</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;      intersection_moments[im] = r3d_moments[im];</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  }</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="keywordflow">else</span> {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    std::vector&lt; MatPoly&lt;3&gt; &gt; mat_poly_tets;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">facetize_decompose</a>(mat_poly_tets);</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <span class="keywordtype">int</span> ntets = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(mat_poly_tets.size());</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    intersection_moments.assign(4, 0.0);</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> itet = 0; itet &lt; ntets; itet++) {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;      std::vector&lt; Plane_t&lt;3&gt; &gt; face_planes;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      mat_poly_tets[itet].face_planes(face_planes);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;      <span class="keywordflow">if</span>(face_planes.size() &lt; 4) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;      <a class="code" href="structr3d__poly.html">r3d_poly</a> intersection = r3dpoly; </div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;      <a class="code" href="structr3d__plane.html">r3d_plane</a> r3d_face_planes[4];</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iplane = 0; iplane &lt; 4; iplane++) {</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;          r3d_face_planes[iplane].n.xyz[ixyz] = -face_planes[iplane].normal[ixyz];</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        r3d_face_planes[iplane].<a class="code" href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">d</a> = -face_planes[iplane].dist2origin;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      }</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;      <a class="code" href="r3d_8h.html#ab3f21c5ada02190326fbe535032bfbe0">r3d_clip</a>(&amp;intersection, r3d_face_planes, 4);</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;      <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;intersection, r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; 4; im++)</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        intersection_moments[im] += r3d_moments[im];</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    }</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;}</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno"><a class="line" href="namespaceTangram.html#a76a989a601d36db6dab4fcec22ed85fe">  601</a></span>&#160;<a class="code" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t&lt;3&gt;</a> <a class="code" href="namespaceTangram.html#a76a989a601d36db6dab4fcec22ed85fe">r3d_poly_bounding_box</a>(<span class="keyword">const</span> <a class="code" href="structr3d__poly.html">r3d_poly</a>&amp; r3dpoly) {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  <a class="code" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t&lt;3&gt;</a> bbox;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ivrt = 0; ivrt &lt; r3dpoly.<a class="code" href="structr3d__poly.html#a49cb139c24b05f1ce30bc385f6938b50">nverts</a>; ivrt++)</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++) {</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;      <span class="keywordflow">if</span> (r3dpoly.<a class="code" href="structr3d__poly.html#a3a696a7627e82ee03e826c5ef5b19fe2">verts</a>[ivrt].<a class="code" href="structr3d__vertex.html#aaf9a4d5cce69d3fbca4ecd7d215071f5">pos</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[idim] &lt; bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">min</a>[idim])</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">min</a>[idim] = r3dpoly.<a class="code" href="structr3d__poly.html#a3a696a7627e82ee03e826c5ef5b19fe2">verts</a>[ivrt].<a class="code" href="structr3d__vertex.html#aaf9a4d5cce69d3fbca4ecd7d215071f5">pos</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[idim];</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      <span class="keywordflow">if</span> (r3dpoly.<a class="code" href="structr3d__poly.html#a3a696a7627e82ee03e826c5ef5b19fe2">verts</a>[ivrt].<a class="code" href="structr3d__vertex.html#aaf9a4d5cce69d3fbca4ecd7d215071f5">pos</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[idim] &gt; bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">max</a>[idim])</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        bbox.<a class="code" href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">max</a>[idim] = r3dpoly.<a class="code" href="structr3d__poly.html#a3a696a7627e82ee03e826c5ef5b19fe2">verts</a>[ivrt].<a class="code" href="structr3d__vertex.html#aaf9a4d5cce69d3fbca4ecd7d215071f5">pos</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[idim];</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    }</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  <span class="keywordflow">return</span> bbox;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;}</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;}  <span class="comment">// namespace Tangram</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="preprocessor">#endif  // TANGRAM_INTERSECT_SPLIT_R3D_H_</span></div><div class="ttc" id="classTangram_1_1ClipR3D_html_a7eb95743fffdde2e24493f7086a25c06"><div class="ttname"><a href="classTangram_1_1ClipR3D.html#a7eb95743fffdde2e24493f7086a25c06">Tangram::ClipR3D::set_plane</a></div><div class="ttdeci">void set_plane(const Plane_t&lt; 3 &gt; &amp;cutting_plane)</div><div class="ttdoc">Set the cutting plane used by the functor. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:420</div></div>
<div class="ttc" id="r3d_8h_html_ae591f11a646bffc0b497ba6d440f326a"><div class="ttname"><a href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a></div><div class="ttdeci">void r3d_reduce(r3d_poly *poly, r3d_real *moments, r3d_int polyorder)</div></div>
<div class="ttc" id="namespaceTangram_html_af02fba4de7b9b6cdae6e0f7b655d96b9"><div class="ttname"><a href="namespaceTangram.html#af02fba4de7b9b6cdae6e0f7b655d96b9">Tangram::get_intersection_moments</a></div><div class="ttdeci">void get_intersection_moments(const MatPoly&lt; 2 &gt; &amp;mat_poly, const r2d_poly &amp;r2dpoly, std::vector&lt; double &gt; &amp;intersection_moments, bool convex_matpoly=false)</div><div class="ttdoc">Computes moments of the intersection of a MatPoly and an r2d_poly. If MatPoly is convex, r2d_poly will be clipped with lines containing the faces of MatPoly. Otherwise, MatPoly will be decomposed into triangular MatPolys, each of which will be intersected with r2d_poly. Note that r2d_poly does not need to be convex. </div><div class="ttdef"><b>Definition:</b> split_r2d.h:117</div></div>
<div class="ttc" id="structTangram_1_1HalfSpaceSets__t_html_a0aaef7e80ff5bcea881e7cacde2a4ab2"><div class="ttname"><a href="structTangram_1_1HalfSpaceSets__t.html#a0aaef7e80ff5bcea881e7cacde2a4ab2">Tangram::HalfSpaceSets_t::upper_halfspace_set</a></div><div class="ttdeci">MatPolySet_t&lt; D &gt; upper_halfspace_set</div><div class="ttdef"><b>Definition:</b> tangram.h:201</div></div>
<div class="ttc" id="structr3d__plane_html_a82422a38dd2d1975d11d9d0ca6172027"><div class="ttname"><a href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">r3d_plane::d</a></div><div class="ttdeci">r3d_real d</div><div class="ttdef"><b>Definition:</b> r3d.h:79</div></div>
<div class="ttc" id="structr3d__brep_html_ada56a04094fa2bdd74ff9085dbb7a85c"><div class="ttname"><a href="structr3d__brep.html#ada56a04094fa2bdd74ff9085dbb7a85c">r3d_brep::numfaces</a></div><div class="ttdeci">r3d_int numfaces</div><div class="ttdef"><b>Definition:</b> r3d.h:357</div></div>
<div class="ttc" id="structr3d__brep_html"><div class="ttname"><a href="structr3d__brep.html">r3d_brep</a></div><div class="ttdef"><b>Definition:</b> r3d.h:351</div></div>
<div class="ttc" id="unionr3d__rvec3_html"><div class="ttname"><a href="unionr3d__rvec3.html">r3d_rvec3</a></div><div class="ttdef"><b>Definition:</b> r3d.h:52</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a8e814a40956aee6c5ade0c20abefe920"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">Tangram::MatPoly::facetize_decompose</a></div><div class="ttdeci">void facetize_decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Facetizes and decomposes this MatPoly into simplex MatPoly&amp;#39;s using its centroid. </div></div>
<div class="ttc" id="structr3d__plane_html_a6447f761d2c41d040a0fbdaa8e2885b1"><div class="ttname"><a href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">r3d_plane::n</a></div><div class="ttdeci">r3d_rvec3 n</div><div class="ttdef"><b>Definition:</b> r3d.h:78</div></div>
<div class="ttc" id="r3d_8h_html_a3aa887a1c16c46e933b08d25625aa024"><div class="ttname"><a href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a></div><div class="ttdeci">int32_t r3d_int</div><div class="ttdoc">Integer types used for indexing. </div><div class="ttdef"><b>Definition:</b> r3d.h:47</div></div>
<div class="ttc" id="classTangram_1_1SplitR3D_html_a7ed232832fa1fcce72d05cf2e0e33e27"><div class="ttname"><a href="classTangram_1_1SplitR3D.html#a7ed232832fa1fcce72d05cf2e0e33e27">Tangram::SplitR3D::operator()</a></div><div class="ttdeci">HalfSpaceSets_t&lt; 3 &gt; operator()() const</div><div class="ttdoc">Splits a MatPoly into two sets of convex MatPoly&amp;#39;s. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:334</div></div>
<div class="ttc" id="r3d_8h_html_a1185134e293f53b23a45bae8543edbd1"><div class="ttname"><a href="r3d_8h.html#a1185134e293f53b23a45bae8543edbd1">r3d_free_brep</a></div><div class="ttdeci">void r3d_free_brep(r3d_brep **brep, r3d_int numcomponents)</div><div class="ttdoc">Free all the memory associated with the boundary representation array. </div></div>
<div class="ttc" id="r3d_8h_html_afcba1d5250f023c0ad724b26f75f7252"><div class="ttname"><a href="r3d_8h.html#afcba1d5250f023c0ad724b26f75f7252">r3d_init_poly</a></div><div class="ttdeci">void r3d_init_poly(r3d_poly *poly, r3d_rvec3 *vertices, r3d_int numverts, r3d_int **faceinds, r3d_int *numvertsperface, r3d_int numfaces)</div><div class="ttdoc">Initialize a general polyhedron from a full boundary description. Can use r3d_is_good to check that t...</div></div>
<div class="ttc" id="namespaceTangram_html_ad21544d74adf6c81745e56cb8a2d4a41"><div class="ttname"><a href="namespaceTangram.html#ad21544d74adf6c81745e56cb8a2d4a41">Tangram::r3dpoly_to_matpolys</a></div><div class="ttdeci">void r3dpoly_to_matpolys(const r3d_poly &amp;r3dpoly, std::vector&lt; MatPoly&lt; 3 &gt; &gt; &amp;mat_polys)</div><div class="ttdoc">Converts a polyhedron in R3D format to MatPoly&amp;#39;s. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:85</div></div>
<div class="ttc" id="structTangram_1_1HalfSpaceSets__t_html_add9a75f9a740f31c1d57305349170690"><div class="ttname"><a href="structTangram_1_1HalfSpaceSets__t.html#add9a75f9a740f31c1d57305349170690">Tangram::HalfSpaceSets_t::lower_halfspace_set</a></div><div class="ttdeci">MatPolySet_t&lt; D &gt; lower_halfspace_set</div><div class="ttdef"><b>Definition:</b> tangram.h:200</div></div>
<div class="ttc" id="classTangram_1_1ClipR3D_html_a81795b3025d7cd0861e1b219195f8826"><div class="ttname"><a href="classTangram_1_1ClipR3D.html#a81795b3025d7cd0861e1b219195f8826">Tangram::ClipR3D::ClipR3D</a></div><div class="ttdeci">ClipR3D()</div><div class="ttdef"><b>Definition:</b> split_r3d.h:414</div></div>
<div class="ttc" id="r3d_8h_html_aa30ff2c6771668f327e1b0e4bd5cb58f"><div class="ttname"><a href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a></div><div class="ttdeci">double r3d_real</div><div class="ttdoc">Real type specifying the precision to be used in calculations. </div><div class="ttdef"><b>Definition:</b> r3d.h:41</div></div>
<div class="ttc" id="structTangram_1_1HalfSpaceSets__t_html"><div class="ttname"><a href="structTangram_1_1HalfSpaceSets__t.html">Tangram::HalfSpaceSets_t</a></div><div class="ttdef"><b>Definition:</b> tangram.h:199</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa756cca3df1a498d170bc3a86e6bae7b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa756cca3df1a498d170bc3a86e6bae7b">Tangram::MatPoly::points</a></div><div class="ttdeci">const std::vector&lt; Point&lt; D &gt; &gt; &amp; points() const</div><div class="ttdoc">Points for all the vertices of the material poly. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:201</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aab5cfa3fff9b96d2cbf96415fe7704af"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aab5cfa3fff9b96d2cbf96415fe7704af">Tangram::MatPoly::face_vertices</a></div><div class="ttdeci">const std::vector&lt; int &gt; &amp; face_vertices(int const face_id) const</div><div class="ttdoc">Indices of vertices of the material poly&amp;#39;s face. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:208</div></div>
<div class="ttc" id="classTangram_1_1SplitR3D_html_a42f491427bb8d9849d9f8a9ba528fe0b"><div class="ttname"><a href="classTangram_1_1SplitR3D.html#a42f491427bb8d9849d9f8a9ba528fe0b">Tangram::SplitR3D::operator=</a></div><div class="ttdeci">SplitR3D &amp; operator=(const SplitR3D &amp;)=delete</div><div class="ttdoc">Assignment operator (disabled) </div></div>
<div class="ttc" id="classTangram_1_1ClipR3D_html"><div class="ttname"><a href="classTangram_1_1ClipR3D.html">Tangram::ClipR3D</a></div><div class="ttdef"><b>Definition:</b> split_r3d.h:412</div></div>
<div class="ttc" id="r3d_8h_html_a4e35e1242db9a7738a98bbf423962b51"><div class="ttname"><a href="r3d_8h.html#a4e35e1242db9a7738a98bbf423962b51">r3d_init_brep</a></div><div class="ttdeci">void r3d_init_brep(const r3d_poly *poly, r3d_brep **brep, r3d_int *numcomponents)</div><div class="ttdoc">Convert from R3D&amp;#39;s internal vertex-edge format to the boundary representation. </div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a82d4a7bb4295c65916aaec1cc03b9a00"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a82d4a7bb4295c65916aaec1cc03b9a00">Tangram::MatPoly::num_faces</a></div><div class="ttdeci">int num_faces() const</div><div class="ttdoc">Number of material poly&amp;#39;s faces. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:283</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html"><div class="ttname"><a href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt; 3 &gt;</a></div></div>
<div class="ttc" id="namespaceTangram_html_a2364ea47380698d6b380574978c068da"><div class="ttname"><a href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">Tangram::matpoly_to_r3dpoly</a></div><div class="ttdeci">void matpoly_to_r3dpoly(const MatPoly&lt; 3 &gt; &amp;mat_poly, r3d_poly &amp;r3dpoly)</div><div class="ttdoc">Converts a MatPoly to a polyhedron in R3D format. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:42</div></div>
<div class="ttc" id="structr3d__brep_html_aafbf7bf0fe6d1d40eda771d747e1a985"><div class="ttname"><a href="structr3d__brep.html#aafbf7bf0fe6d1d40eda771d747e1a985">r3d_brep::numvertsperface</a></div><div class="ttdeci">r3d_int * numvertsperface</div><div class="ttdef"><b>Definition:</b> r3d.h:356</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html_aeb5db1642a6d790563f1ae78154de428"><div class="ttname"><a href="structTangram_1_1Plane__t.html#aeb5db1642a6d790563f1ae78154de428">Tangram::Plane_t::normal</a></div><div class="ttdeci">Vector&lt; D &gt; normal</div><div class="ttdef"><b>Definition:</b> tangram.h:173</div></div>
<div class="ttc" id="classTangram_1_1Point_html"><div class="ttname"><a href="classTangram_1_1Point.html">Tangram::Point</a></div><div class="ttdoc">Represents a point in an N-dimensional space. </div><div class="ttdef"><b>Definition:</b> Point.h:48</div></div>
<div class="ttc" id="namespaceTangram_html"><div class="ttname"><a href="namespaceTangram.html">Tangram</a></div><div class="ttdef"><b>Definition:</b> CellMatPoly.h:18</div></div>
<div class="ttc" id="classTangram_1_1ClipR3D_html_a889c4f4815e82cf3d668249c9f58c025"><div class="ttname"><a href="classTangram_1_1ClipR3D.html#a889c4f4815e82cf3d668249c9f58c025">Tangram::ClipR3D::aggregated_moments</a></div><div class="ttdeci">std::vector&lt; double &gt; aggregated_moments()</div><div class="ttdoc">Computes moments of provided material polyhedra. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:454</div></div>
<div class="ttc" id="r3d_8h_html_ab3f21c5ada02190326fbe535032bfbe0"><div class="ttname"><a href="r3d_8h.html#ab3f21c5ada02190326fbe535032bfbe0">r3d_clip</a></div><div class="ttdeci">void r3d_clip(r3d_poly *poly, const r3d_plane *planes, r3d_int nplanes)</div><div class="ttdoc">Clip a polyhedron against an arbitrary number of clip planes (find its intersection with a set of hal...</div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html">Tangram::BoundingBox_t</a></div><div class="ttdef"><b>Definition:</b> tangram.h:227</div></div>
<div class="ttc" id="tangram_8h_html"><div class="ttname"><a href="tangram_8h.html">tangram.h</a></div></div>
<div class="ttc" id="structr3d__poly_html_a3a696a7627e82ee03e826c5ef5b19fe2"><div class="ttname"><a href="structr3d__poly.html#a3a696a7627e82ee03e826c5ef5b19fe2">r3d_poly::verts</a></div><div class="ttdeci">r3d_vertex verts[R3D_MAX_VERTS]</div><div class="ttdef"><b>Definition:</b> r3d.h:96</div></div>
<div class="ttc" id="structr3d__brep_html_a1112473427a084ceeecbc603dbeaf65a"><div class="ttname"><a href="structr3d__brep.html#a1112473427a084ceeecbc603dbeaf65a">r3d_brep::numvertices</a></div><div class="ttdeci">r3d_int numvertices</div><div class="ttdef"><b>Definition:</b> r3d.h:354</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html_a0de6ac6eb2b34ebc3d70ced8df621ce5"><div class="ttname"><a href="structTangram_1_1Plane__t.html#a0de6ac6eb2b34ebc3d70ced8df621ce5">Tangram::Plane_t::dist2origin</a></div><div class="ttdeci">double dist2origin</div><div class="ttdef"><b>Definition:</b> tangram.h:174</div></div>
<div class="ttc" id="namespaceTangram_html_a3b33cbabca7f3d25bf3a39d72909f1be"><div class="ttname"><a href="namespaceTangram.html#a3b33cbabca7f3d25bf3a39d72909f1be">Tangram::split_convex_matpoly_r3d</a></div><div class="ttdeci">void split_convex_matpoly_r3d(const MatPoly&lt; 3 &gt; &amp;mat_poly, const Plane_t&lt; 3 &gt; &amp;cutting_plane, MatPoly&lt; 3 &gt; &amp;lower_halfspace_poly, MatPoly&lt; 3 &gt; &amp;upper_halfspace_poly, std::vector&lt; double &gt; &amp;lower_halfspace_moments, std::vector&lt; double &gt; &amp;upper_halfspace_moments)</div><div class="ttdoc">Splits a convex MatPoly into two (convex) MatPoly&amp;#39;s with a cutting plane. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:246</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a860f132a1987d539089fc1c80c7404a7"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a860f132a1987d539089fc1c80c7404a7">Tangram::MatPoly::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Resets the MatPoly data. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:173</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html"><div class="ttname"><a href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt; 3 &gt;</a></div></div>
<div class="ttc" id="structr3d__brep_html_adaa9649c626cb6f0e1959eeac9617520"><div class="ttname"><a href="structr3d__brep.html#adaa9649c626cb6f0e1959eeac9617520">r3d_brep::faceinds</a></div><div class="ttdeci">r3d_int ** faceinds</div><div class="ttdef"><b>Definition:</b> r3d.h:355</div></div>
<div class="ttc" id="classTangram_1_1SplitR3D_html"><div class="ttname"><a href="classTangram_1_1SplitR3D.html">Tangram::SplitR3D</a></div><div class="ttdef"><b>Definition:</b> split_r3d.h:320</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa5681ccd23930482bb6b3c243fb4425c"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa5681ccd23930482bb6b3c243fb4425c">Tangram::MatPoly::faceted_matpoly</a></div><div class="ttdeci">void faceted_matpoly(MatPoly&lt; 2 &gt; *faceted_poly) const</div><div class="ttdoc">Facetization of the 2D polygon&amp;#39;s boundary: simply creates a copy of the polygon. </div></div>
<div class="ttc" id="structr3d__plane_html"><div class="ttname"><a href="structr3d__plane.html">r3d_plane</a></div><div class="ttdef"><b>Definition:</b> r3d.h:76</div></div>
<div class="ttc" id="structr3d__poly_html_a49cb139c24b05f1ce30bc385f6938b50"><div class="ttname"><a href="structr3d__poly.html#a49cb139c24b05f1ce30bc385f6938b50">r3d_poly::nverts</a></div><div class="ttdeci">r3d_int nverts</div><div class="ttdef"><b>Definition:</b> r3d.h:97</div></div>
<div class="ttc" id="classTangram_1_1ClipR3D_html_a03f40eaf0c37b20926cd90923efe93ac"><div class="ttname"><a href="classTangram_1_1ClipR3D.html#a03f40eaf0c37b20926cd90923efe93ac">Tangram::ClipR3D::set_matpolys</a></div><div class="ttdeci">void set_matpolys(const std::vector&lt; MatPoly&lt; 3 &gt; &gt; &amp;matpolys, const bool planar_faces=false)</div><div class="ttdoc">Set the material polyhedra to be used by the functor. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:432</div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html_ad4ae706e0bc47e7416cfb1dc2d12d3db"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html#ad4ae706e0bc47e7416cfb1dc2d12d3db">Tangram::BoundingBox_t::max</a></div><div class="ttdeci">double max[D]</div><div class="ttdef"><b>Definition:</b> tangram.h:229</div></div>
<div class="ttc" id="structr3d__poly_html"><div class="ttname"><a href="structr3d__poly.html">r3d_poly</a></div><div class="ttdef"><b>Definition:</b> r3d.h:93</div></div>
<div class="ttc" id="namespaceTangram_html_a76a989a601d36db6dab4fcec22ed85fe"><div class="ttname"><a href="namespaceTangram.html#a76a989a601d36db6dab4fcec22ed85fe">Tangram::r3d_poly_bounding_box</a></div><div class="ttdeci">BoundingBox_t&lt; 3 &gt; r3d_poly_bounding_box(const r3d_poly &amp;r3dpoly)</div><div class="ttdef"><b>Definition:</b> split_r3d.h:601</div></div>
<div class="ttc" id="structr3d__vertex_html_aaf9a4d5cce69d3fbca4ecd7d215071f5"><div class="ttname"><a href="structr3d__vertex.html#aaf9a4d5cce69d3fbca4ecd7d215071f5">r3d_vertex::pos</a></div><div class="ttdeci">r3d_rvec3 pos</div><div class="ttdef"><b>Definition:</b> r3d.h:87</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aba885f75525c109661a08cb41a413a5b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">Tangram::MatPoly::face_planes</a></div><div class="ttdeci">void face_planes(std::vector&lt; Plane_t&lt; D &gt; &gt; &amp;fplanes) const</div><div class="ttdoc">For every face, returns a plane containing that face. Important: faces should be planar, so you might need to facetize the MatPoly first. Faces with area below machine epsilon will be omitted. If the number of valid planes is less than four, empty vector will be returned. </div></div>
<div class="ttc" id="unionr3d__rvec3_html_ab127c0310533e3caaafcad80b7280fe1"><div class="ttname"><a href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">r3d_rvec3::xyz</a></div><div class="ttdeci">r3d_real xyz[3]</div><div class="ttdef"><b>Definition:</b> r3d.h:59</div></div>
<div class="ttc" id="classTangram_1_1SplitR3D_html_ab450a03d544623c8dc7e63799489d678"><div class="ttname"><a href="classTangram_1_1SplitR3D.html#ab450a03d544623c8dc7e63799489d678">Tangram::SplitR3D::SplitR3D</a></div><div class="ttdeci">SplitR3D(const std::vector&lt; MatPoly&lt; 3 &gt; &gt; &amp;matpolys, const Plane_t&lt; 3 &gt; &amp;cutting_plane, const bool all_convex=false)</div><div class="ttdef"><b>Definition:</b> split_r3d.h:322</div></div>
<div class="ttc" id="r3d_8h_html_ace7c6f2c67e44a0a24c13f4cd1dbf138"><div class="ttname"><a href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a></div><div class="ttdeci">#define R3D_NUM_MOMENTS(order)</div><div class="ttdoc">Integrate a polynomial density over a polyhedron using simplicial decomposition. Uses the fast recurs...</div><div class="ttdef"><b>Definition:</b> r3d.h:154</div></div>
<div class="ttc" id="r3d_8h_html_aad337c9fbabbd571b25490c27f3709d9"><div class="ttname"><a href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a></div><div class="ttdeci">void r3d_split(r3d_poly *inpolys, r3d_int npolys, r3d_plane plane, r3d_poly *out_pos, r3d_poly *out_neg)</div><div class="ttdoc">Splits a list of polyhedra across a single plane. </div></div>
<div class="ttc" id="MatPoly_8h_html"><div class="ttname"><a href="MatPoly_8h.html">MatPoly.h</a></div></div>
<div class="ttc" id="structTangram_1_1BoundingBox__t_html_ab255aa2370f495b3c8b00f2a92ea72b0"><div class="ttname"><a href="structTangram_1_1BoundingBox__t.html#ab255aa2370f495b3c8b00f2a92ea72b0">Tangram::BoundingBox_t::min</a></div><div class="ttdeci">double min[D]</div><div class="ttdef"><b>Definition:</b> tangram.h:228</div></div>
<div class="ttc" id="namespaceTangram_html_a71c39deca72d48990415ee231a9170b1"><div class="ttname"><a href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">Tangram::vector</a></div><div class="ttdeci">std::vector&lt; T &gt; vector</div><div class="ttdef"><b>Definition:</b> tangram.h:137</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aa32646522284f28e04aad59e815542f1"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aa32646522284f28e04aad59e815542f1">Tangram::MatPoly::num_vertices</a></div><div class="ttdeci">int num_vertices() const</div><div class="ttdoc">Number of material poly&amp;#39;s vertices. </div><div class="ttdef"><b>Definition:</b> MatPoly.h:278</div></div>
<div class="ttc" id="classTangram_1_1SplitR3D_html_a50460daa5a59221d09431b9ee40fce01"><div class="ttname"><a href="classTangram_1_1SplitR3D.html#a50460daa5a59221d09431b9ee40fce01">Tangram::SplitR3D::SplitR3D</a></div><div class="ttdeci">SplitR3D()=delete</div><div class="ttdoc">Default constructor (disabled) </div></div>
</div><!-- fragment --></div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2017
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
