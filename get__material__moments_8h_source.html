<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>tangram: /home/portage/tangram/tangram/utility/get_material_moments.h Source File</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_043c38e9c2239d2104f02eee845ed8d8.html">tangram</a></li><li class="navelem"><a class="el" href="dir_8c062d6981e3de3ea58d7a81e2ec1253.html">utility</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">get_material_moments.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="get__material__moments_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> This file is part of the Ristra tangram project.</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> Please see the license file at the root of this repository, or at:</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> https://github.com/laristra/tangram/blob/master/LICENSE</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#ifndef GET_MATERIAL_MOMENTS_H_</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#define GET_MATERIAL_MOMENTS_H_</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="tangram_8h.html">tangram/support/tangram.h</a>&quot;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="split__r2d_8h.html">tangram/intersect/split_r2d.h</a>&quot;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="split__r3d_8h.html">tangram/intersect/split_r3d.h</a>&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="primitives_8h.html">tangram/utility/rpgtools/primitives.h</a>&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="cuts_8h.html">tangram/utility/rpgtools/cuts.h</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00044"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">   44</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                          <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt;3&gt;</a> &gt;&amp; planar_interfaces,</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> vol_tol,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol,</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">bool</span> decompose_cells,</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r3d_poly&gt; &gt; &gt;*</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                            reference_mat_polys = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="keywordtype">int</span> nplanes = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(planar_interfaces.size());</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  assert(material_IDs.size() == nplanes + 1);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  </div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  </div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  <span class="comment">//Get convex MatPoly&#39;s for every cell</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  std::vector&lt; std::vector&lt; Tangram::MatPoly&lt;3&gt; &gt; &gt; cells_polys(ncells);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  std::vector&lt;int&gt; cur_polys_cellID;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;3&gt;</a> mat_poly;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">Tangram::cell_get_matpoly</a>(mesh, icell, &amp;mat_poly, dst_tol);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">if</span> (decompose_cells) {</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">facetize_decompose</a>(cells_polys[icell]);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;      cur_polys_cellID.resize(</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        cur_polys_cellID.size() + cells_polys[icell].size(), icell);</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    }</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      cells_polys[icell].push_back(mat_poly);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      cur_polys_cellID.push_back(icell);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  }</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  <span class="keywordtype">int</span> ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_polys_cellID.size());</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <a class="code" href="structr3d__poly.html">r3d_poly</a>* cur_r3d_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordtype">int</span> nmoments = <a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="keywordtype">int</span> ir3d_poly = 0;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  std::vector&lt; std::vector&lt;double&gt; &gt; cur_polys_moments(ncur_polys);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++)</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; cells_polys[icell].size(); ipoly++) {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">Tangram::matpoly_to_r3dpoly</a>(cells_polys[icell][ipoly], cur_r3d_polys[ir3d_poly]);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;cur_r3d_polys[ir3d_poly], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      cur_polys_moments[ir3d_poly].resize(nmoments);</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        cur_polys_moments[ir3d_poly][im] += r3d_moments[im];</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      ir3d_poly++;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    }</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; cells_mat_ids(ncells);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    reference_mat_polys-&gt;clear();</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    reference_mat_polys-&gt;resize(ncells);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  }</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  std::vector&lt; std::vector&lt; std::vector&lt;double&gt; &gt; &gt; cells_mat_moments(ncells);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iplane = 0; iplane &lt; nplanes; iplane++) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordtype">int</span> cur_mat_id = material_IDs[iplane];</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <a class="code" href="structr3d__plane.html">r3d_plane</a> cur_r3d_plane;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;      cur_r3d_plane.<a class="code" href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">n</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[ixyz] = planar_interfaces[iplane].normal[ixyz];</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    cur_r3d_plane.<a class="code" href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">d</a> = planar_interfaces[iplane].dist2origin;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* lower_hs_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* upper_hs_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <a class="code" href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a>(cur_r3d_polys, (<a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>) ncur_polys, cur_r3d_plane, </div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;              upper_hs_polys, lower_hs_polys);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keyword">delete</span> [] cur_r3d_polys;          </div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    std::vector&lt;int&gt; iremaining_polys;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    std::vector&lt; std::vector&lt;double&gt; &gt; remaining_polys_moments;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      <span class="keywordtype">bool</span> nnz_cutoff = <span class="keyword">false</span>;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      <span class="keywordflow">if</span> (lower_hs_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;lower_hs_polys[ipoly], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">if</span> (r3d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          nnz_cutoff = <span class="keyword">true</span>;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;          <span class="comment">// Poly below the plane is cut off by the plane, add it to </span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;          <span class="comment">// the cell&#39;s list of single-material poly&#39;s</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;          <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;          <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                      cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;          <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>) </div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;              (*reference_mat_polys)[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;          }</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;          <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            (*reference_mat_polys)[icell][cell_mat_id].push_back(lower_hs_polys[ipoly]);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            cells_mat_moments[icell][cell_mat_id][im] += r3d_moments[im];</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;        }</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      <span class="keywordflow">if</span> (upper_hs_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordflow">if</span> (nnz_cutoff) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            r3d_moments[im] = cur_polys_moments[ipoly][im] - r3d_moments[im];</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        } </div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            r3d_moments[im] = cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        <span class="keywordflow">if</span> (r3d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;          <span class="keywordtype">int</span> irpoly = iremaining_polys.size();</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;          iremaining_polys.push_back(ipoly);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;          remaining_polys_moments.resize(irpoly + 1);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;          remaining_polys_moments[irpoly].resize(nmoments);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;            remaining_polys_moments[irpoly][im] = r3d_moments[im];</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;        }</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    }</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keyword">delete</span> [] lower_hs_polys;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(iremaining_polys.size());</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* remaining_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    std::vector&lt;int&gt; remaining_polys_cellID(ncur_polys);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irpoly = 0; irpoly &lt; ncur_polys; irpoly++) {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      remaining_polys[irpoly] = upper_hs_polys[iremaining_polys[irpoly]];</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;      remaining_polys_cellID[irpoly] = cur_polys_cellID[iremaining_polys[irpoly]];</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    }</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keyword">delete</span> [] upper_hs_polys;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    cur_r3d_polys = remaining_polys;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    cur_polys_cellID = remaining_polys_cellID;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    cur_polys_moments = remaining_polys_moments;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  <span class="comment">//Poly&#39;s that are left after all planes were processed are also single-material</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="keywordtype">int</span> cur_mat_id = material_IDs[nplanes];</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        (*reference_mat_polys)[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    }</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      (*reference_mat_polys)[icell][cell_mat_id].push_back(cur_r3d_polys[ipoly]);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      cells_mat_moments[icell][cell_mat_id][im] += cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  <span class="keyword">delete</span> [] cur_r3d_polys;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  cell_num_mats.resize(ncells);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  cell_mat_ids.clear();</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  cell_mat_volfracs.clear();</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  cell_mat_centroids.clear();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    cell_num_mats[icell] = cells_mat_ids[icell].size();</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    cell_mat_ids.insert(cell_mat_ids.end(), cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                        cells_mat_ids[icell].end());</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordtype">int</span> offset = cell_mat_volfracs.size();</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    cell_mat_volfracs.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    cell_mat_centroids.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordtype">double</span> cell_volume = mesh.cell_volume(icell);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> imat = 0; imat &lt; cell_num_mats[icell]; imat++) {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      cell_mat_volfracs[offset + imat] = </div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        cells_mat_moments[icell][imat][0]/cell_volume;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        cell_mat_centroids[offset + imat][idim] = </div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;          cells_mat_moments[icell][imat][idim + 1]/cells_mat_moments[icell][imat][0];</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;  }</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00266"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#a6c07aeaba1c55dd83b96c0d4659832da">  266</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                          <span class="keyword">const</span> <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a>&amp; center,</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> radius,</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">int</span> nquadrant_samples,</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> vol_tol,</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol,</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">bool</span> decompose_cells,</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r3d_poly&gt; &gt; &gt;*</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                            reference_mat_polys = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  assert(material_IDs.size() == 2);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  </div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;3&gt;</a> sphere_poly = <a class="code" href="primitives_8h.html#a39487a4df0863383e76a5cfae81bff5e">sphere</a>(center, radius, nquadrant_samples, dst_tol);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  std::vector&lt; std::shared_ptr&lt;RefPolyData_t&gt; &gt; mesh_polys;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  mesh_to_r3d_polys&lt;Mesh_Wrapper&gt;(mesh, mesh_polys, dst_tol, decompose_cells);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  std::vector&lt; std::vector&lt; std::shared_ptr&lt;RefPolyData_t&gt; &gt; &gt; ref_poly_sets(2);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <a class="code" href="cuts_8h.html#ada8f3f960ae9834b492be70f14ca85fa">apply_poly</a>(mesh_polys, sphere_poly, ref_poly_sets[1], ref_poly_sets[0],</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;             vol_tol, dst_tol, <span class="keyword">true</span>);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  mesh_polys.clear();             </div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  <a class="code" href="cuts_8h.html#af4145e83e4fe14c7e3a657eafca5c939">finalize_ref_data</a>(mesh, ref_poly_sets, material_IDs, cell_num_mats, cell_mat_ids, </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    cell_mat_volfracs, cell_mat_centroids, dst_tol, decompose_cells, reference_mat_polys);</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;}</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00331"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#ac25bd12e9f40da0f173665fb44e2ba86">  331</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                          <span class="keyword">const</span> <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a>&amp; center,</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                          <span class="keyword">const</span> std::vector&lt;double&gt;&amp; radius,</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">int</span> nquadrant_samples,</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> vol_tol,</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol,</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">bool</span> decompose_cells,</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r3d_poly&gt; &gt; &gt;*</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                            reference_mat_polys = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  <span class="keywordtype">int</span> nspheres = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(radius.size());</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  assert(material_IDs.size() == nspheres + 1);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  </div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  std::vector&lt; std::shared_ptr&lt;RefPolyData_t&gt; &gt; mesh_polys, cur_polys_data, rem_polys_data;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  mesh_to_r3d_polys&lt;Mesh_Wrapper&gt;(mesh, mesh_polys, dst_tol, decompose_cells);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  std::vector&lt; std::vector&lt; std::shared_ptr&lt;RefPolyData_t&gt; &gt; &gt; ref_poly_sets(nspheres + 1);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  cur_polys_data = mesh_polys;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  mesh_polys.clear();</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> isphere = 0; isphere &lt; nspheres; isphere++) {</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;3&gt;</a> sphere_poly = <a class="code" href="primitives_8h.html#a39487a4df0863383e76a5cfae81bff5e">sphere</a>(center, radius[isphere], </div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                                             nquadrant_samples, dst_tol);</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <a class="code" href="cuts_8h.html#ada8f3f960ae9834b492be70f14ca85fa">apply_poly</a>(cur_polys_data, sphere_poly, ref_poly_sets[isphere], rem_polys_data, </div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;               vol_tol, dst_tol, <span class="keyword">true</span>);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    cur_polys_data = rem_polys_data;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    rem_polys_data.clear();</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  }</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  ref_poly_sets[nspheres] = cur_polys_data;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  <a class="code" href="cuts_8h.html#af4145e83e4fe14c7e3a657eafca5c939">finalize_ref_data</a>(mesh,ref_poly_sets, material_IDs, cell_num_mats, cell_mat_ids, </div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    cell_mat_volfracs, cell_mat_centroids, dst_tol, decompose_cells, reference_mat_polys);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;}</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00396"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#a7030ced19f6cede5aca16f5d242b89be">  396</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                          <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt;2&gt;</a> &gt;&amp; linear_interfaces,</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;2&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> vol_tol,</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol,</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">bool</span> decompose_cells,</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r2d_poly&gt; &gt; &gt;*</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                            reference_mat_polys = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  <span class="keywordtype">int</span> nlines = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(linear_interfaces.size());</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  assert(material_IDs.size() == nlines + 1);</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  </div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;  </div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="comment">//Get convex MatPoly&#39;s for every cell</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;  std::vector&lt; std::vector&lt; Tangram::MatPoly&lt;2&gt; &gt; &gt; cells_polys(ncells);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  std::vector&lt;int&gt; cur_polys_cellID;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;2&gt;</a> mat_poly;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <a class="code" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">Tangram::cell_get_matpoly</a>(mesh, icell, &amp;mat_poly, dst_tol);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">if</span> (decompose_cells) {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;      mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">decompose</a>(cells_polys[icell]);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      cur_polys_cellID.resize(</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        cur_polys_cellID.size() + cells_polys[icell].size(), icell);</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      cells_polys[icell].push_back(mat_poly);</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;      cur_polys_cellID.push_back(icell);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;  }</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  <span class="keywordtype">int</span> ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_polys_cellID.size());</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  <a class="code" href="structr2d__poly.html">r2d_poly</a>* cur_r2d_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <span class="keywordtype">int</span> nmoments = <a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <a class="code" href="r2d_8h.html#a7051e2a3074dcda55d4ffe56a31c910c">r2d_real</a> r2d_moments[<a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <span class="keywordtype">int</span> ir2d_poly = 0;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  std::vector&lt; std::vector&lt;double&gt; &gt; cur_polys_moments(ncur_polys);</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++)</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; cells_polys[icell].size(); ipoly++) {</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      <a class="code" href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">Tangram::matpoly_to_r2dpoly</a>(cells_polys[icell][ipoly], cur_r2d_polys[ir2d_poly]);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;cur_r2d_polys[ir2d_poly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      cur_polys_moments[ir2d_poly].resize(nmoments);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        cur_polys_moments[ir2d_poly][im] += r2d_moments[im];</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;      ir2d_poly++;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    }</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; cells_mat_ids(ncells);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    reference_mat_polys-&gt;clear();</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    reference_mat_polys-&gt;resize(ncells);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  }</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  std::vector&lt; std::vector&lt; std::vector&lt;double&gt; &gt; &gt; cells_mat_moments(ncells);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iline = 0; iline &lt; nlines; iline++) {</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordtype">int</span> cur_mat_id = material_IDs[iline];</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <a class="code" href="structr2d__plane.html">r2d_plane</a> cur_r2d_plane;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixy = 0; ixy &lt; 2; ixy++)</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      cur_r2d_plane.<a class="code" href="structr2d__plane.html#aab3829f60a24bbfe6af8ba1d237e7935">n</a>.<a class="code" href="unionr2d__rvec2.html#ad9a1cfdc5716855be5fff46ff18550e4">xy</a>[ixy] = -linear_interfaces[iline].normal[ixy];</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    cur_r2d_plane.<a class="code" href="structr2d__plane.html#a51f453b0f5dc7ec389fc33d46886f0d6">d</a> = -linear_interfaces[iline].dist2origin;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* lower_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* upper_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <a class="code" href="r2d_8h.html#a4e28f6b07d5799645b1590201dc20b69">r2d_split</a>(cur_r2d_polys, (<a class="code" href="r2d_8h.html#a40c43d55f6372345f355d5f34eb919c5">r2d_int</a>) ncur_polys, cur_r2d_plane, </div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;              upper_hp_polys, lower_hp_polys);</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="keyword">delete</span> [] cur_r2d_polys;          </div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    std::vector&lt;int&gt; iremaining_polys;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    std::vector&lt; std::vector&lt;double&gt; &gt; remaining_polys_moments;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <span class="keywordtype">bool</span> nnz_cutoff = <span class="keyword">false</span>;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;      <span class="keywordflow">if</span> (lower_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;        <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;lower_hp_polys[ipoly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;          nnz_cutoff = <span class="keyword">true</span>;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;          <span class="comment">// Poly below the line is cut off by the line, add it to </span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;          <span class="comment">// the cell&#39;s list of single-material poly&#39;s</span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;          <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;          <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                      cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;          <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;            cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;            cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;              (*reference_mat_polys)[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;          }</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;          <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            (*reference_mat_polys)[icell][cell_mat_id].push_back(lower_hp_polys[ipoly]);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            cells_mat_moments[icell][cell_mat_id][im] += r2d_moments[im];</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        }</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;      }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      <span class="keywordflow">if</span> (upper_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;        <span class="keywordflow">if</span> (nnz_cutoff) {</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im] - r2d_moments[im];</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        } </div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        }</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;          <span class="keywordtype">int</span> irpoly = iremaining_polys.size();</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          iremaining_polys.push_back(ipoly);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;          remaining_polys_moments.resize(irpoly + 1);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;          remaining_polys_moments[irpoly].resize(nmoments);</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            remaining_polys_moments[irpoly][im] = r2d_moments[im];</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        }</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keyword">delete</span> [] lower_hp_polys;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(iremaining_polys.size());</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* remaining_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    std::vector&lt;int&gt; remaining_polys_cellID(ncur_polys);</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irpoly = 0; irpoly &lt; ncur_polys; irpoly++) {</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;      remaining_polys[irpoly] = upper_hp_polys[iremaining_polys[irpoly]];</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;      remaining_polys_cellID[irpoly] = cur_polys_cellID[iremaining_polys[irpoly]];</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    }</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="keyword">delete</span> [] upper_hp_polys;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    cur_r2d_polys = remaining_polys;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    cur_polys_cellID = remaining_polys_cellID;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    cur_polys_moments = remaining_polys_moments;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  }</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;  <span class="comment">//Poly&#39;s that are left after all lines were processed are also single-material</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  <span class="keywordtype">int</span> cur_mat_id = material_IDs[nlines];</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;      std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;      cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;      cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;      cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;      cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;      <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        (*reference_mat_polys)[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    }</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;      (*reference_mat_polys)[icell][cell_mat_id].push_back(cur_r2d_polys[ipoly]);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;      cells_mat_moments[icell][cell_mat_id][im] += cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  <span class="keyword">delete</span> [] cur_r2d_polys;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  cell_num_mats.resize(ncells);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  cell_mat_ids.clear();</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  cell_mat_volfracs.clear();</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  cell_mat_centroids.clear();</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    cell_num_mats[icell] = cells_mat_ids[icell].size();</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    cell_mat_ids.insert(cell_mat_ids.end(), cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;                        cells_mat_ids[icell].end());</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keywordtype">int</span> offset = cell_mat_volfracs.size();</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    cell_mat_volfracs.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    cell_mat_centroids.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    <span class="keywordtype">double</span> cell_volume = mesh.cell_volume(icell);</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> imat = 0; imat &lt; cell_num_mats[icell]; imat++) {</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;      cell_mat_volfracs[offset + imat] = </div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;        cells_mat_moments[icell][imat][0]/cell_volume;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 2; idim++)</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        cell_mat_centroids[offset + imat][idim] = </div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;          cells_mat_moments[icell][imat][idim + 1]/cells_mat_moments[icell][imat][0];</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    }</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  }</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;}</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00617"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#af6ada6b9ca1be7d9b60396d03d3c8efe">  617</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                          <span class="keyword">const</span> <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;2&gt;</a>&amp; center,</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> radius,</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">int</span> nquadrant_samples,</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;2&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> vol_tol,</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">double</span> dst_tol,</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">bool</span> decompose_cells,</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r2d_poly&gt; &gt; &gt;*</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;                            reference_mat_polys = <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  assert(material_IDs.size() == 2);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  </div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="comment">// Create a MatPoly that represents the circle</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  <span class="keywordtype">int</span> ncircle_samples = 4*nquadrant_samples;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  std::vector&lt;Tangram::Point&lt;2&gt;&gt; circle_pts;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  circle_pts.reserve(ncircle_samples);</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipt = 0; ipt &lt; ncircle_samples; ipt++) {</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keywordtype">double</span> angle = 2*ipt*<a class="code" href="primitives_8h.html#a299aabc5fc8285cbf99025330a3d0d0d">PI</a>/ncircle_samples;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    circle_pts.push_back(<a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;2&gt;</a>(</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;      center[0] + radius*cos(angle),</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      center[1] + radius*sin(angle)));</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;  }</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;2&gt;</a> circle_poly;</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  circle_poly.<a class="code" href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">initialize</a>(circle_pts, dst_tol);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="comment">// Get the lines containing the circle&#39;s faces</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  std::vector&lt; Tangram::Plane_t&lt;2&gt; &gt; face_lines;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  circle_poly.<a class="code" href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">face_planes</a>(face_lines);</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;  <span class="comment">//Get convex MatPoly&#39;s for every cell</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;  std::vector&lt; std::vector&lt; Tangram::MatPoly&lt;2&gt; &gt; &gt; cells_polys(ncells);</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  std::vector&lt;int&gt; cur_polys_cellID;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;2&gt;</a> mat_poly;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <a class="code" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">Tangram::cell_get_matpoly</a>(mesh, icell, &amp;mat_poly, dst_tol);</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keywordflow">if</span> (decompose_cells) {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;      mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">decompose</a>(cells_polys[icell]);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;      cur_polys_cellID.resize(</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        cur_polys_cellID.size() + cells_polys[icell].size(), icell);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;      cells_polys[icell].push_back(mat_poly);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;      cur_polys_cellID.push_back(icell);</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    }</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  }</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;  <span class="keywordtype">int</span> ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_polys_cellID.size());</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  <a class="code" href="structr2d__poly.html">r2d_poly</a>* cur_r2d_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  <span class="keywordtype">int</span> nmoments = <a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER);</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <a class="code" href="r2d_8h.html#a7051e2a3074dcda55d4ffe56a31c910c">r2d_real</a> r2d_moments[<a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  <span class="keywordtype">int</span> ir2d_poly = 0;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  std::vector&lt; std::vector&lt;double&gt; &gt; cur_polys_moments(ncur_polys);</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++)</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; cells_polys[icell].size(); ipoly++) {</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;      <a class="code" href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">Tangram::matpoly_to_r2dpoly</a>(cells_polys[icell][ipoly], cur_r2d_polys[ir2d_poly]);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;      <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;cur_r2d_polys[ir2d_poly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;      cur_polys_moments[ir2d_poly].resize(nmoments);</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        cur_polys_moments[ir2d_poly][im] += r2d_moments[im];</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;      ir2d_poly++;</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    }</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; cells_mat_ids(ncells);</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    reference_mat_polys-&gt;clear();</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    reference_mat_polys-&gt;resize(ncells);</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  }</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  std::vector&lt; std::vector&lt; std::vector&lt;double&gt; &gt; &gt; cells_mat_moments(ncells);</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  <span class="keywordtype">int</span> nlines = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(face_lines.size());</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iline = 0; iline &lt; nlines; iline++) {</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <a class="code" href="structr2d__plane.html">r2d_plane</a> cur_r2d_plane;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixy = 0; ixy &lt; 2; ixy++)</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;      cur_r2d_plane.<a class="code" href="structr2d__plane.html#aab3829f60a24bbfe6af8ba1d237e7935">n</a>.<a class="code" href="unionr2d__rvec2.html#ad9a1cfdc5716855be5fff46ff18550e4">xy</a>[ixy] = -face_lines[iline].normal[ixy];</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    cur_r2d_plane.<a class="code" href="structr2d__plane.html#a51f453b0f5dc7ec389fc33d46886f0d6">d</a> = -face_lines[iline].dist2origin;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* lower_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* upper_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <a class="code" href="r2d_8h.html#a4e28f6b07d5799645b1590201dc20b69">r2d_split</a>(cur_r2d_polys, (<a class="code" href="r2d_8h.html#a40c43d55f6372345f355d5f34eb919c5">r2d_int</a>) ncur_polys, cur_r2d_plane, </div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;              upper_hp_polys, lower_hp_polys);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <span class="keyword">delete</span> [] cur_r2d_polys;          </div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    std::vector&lt;int&gt; iremaining_polys;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    std::vector&lt; std::vector&lt;double&gt; &gt; remaining_polys_moments;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;      <span class="keywordtype">bool</span> nnz_cutoff = <span class="keyword">false</span>;</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;      <span class="keywordflow">if</span> (upper_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;        <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;upper_hp_polys[ipoly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;          nnz_cutoff = <span class="keyword">true</span>;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;          <span class="comment">// Poly above the line is exterior with respect to the circle,</span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;          <span class="comment">// add it to the list of cell&#39;s poly&#39;s, which currently can only</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;          <span class="comment">// contain exterior material with ID material_IDs[0]</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;          <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;          <span class="keywordflow">if</span> (cells_mat_ids[icell].empty()) {</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;            cells_mat_ids[icell].push_back(material_IDs[0]);</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            cells_mat_moments[icell].resize(1);</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;            cells_mat_moments[icell][0].resize(nmoments, 0.0);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;              (*reference_mat_polys)[icell].resize(1);</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;          }</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;          <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;            (*reference_mat_polys)[icell][0].push_back(upper_hp_polys[ipoly]);</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;            cells_mat_moments[icell][0][im] += r2d_moments[im];</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        }</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;      }</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;      <span class="keywordflow">if</span> (lower_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        <span class="keywordflow">if</span> (nnz_cutoff) {</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im] - r2d_moments[im];</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        } </div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;        }</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt;= vol_tol) {</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;          <span class="keywordtype">int</span> irpoly = iremaining_polys.size();</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;          iremaining_polys.push_back(ipoly);</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;          remaining_polys_moments.resize(irpoly + 1);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;          remaining_polys_moments[irpoly].resize(nmoments);</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            remaining_polys_moments[irpoly][im] = r2d_moments[im];</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        }</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;      }</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    }</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    <span class="keyword">delete</span> [] upper_hp_polys;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(iremaining_polys.size());</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* remaining_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;    std::vector&lt;int&gt; remaining_polys_cellID(ncur_polys);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irpoly = 0; irpoly &lt; ncur_polys; irpoly++) {</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      remaining_polys[irpoly] = lower_hp_polys[iremaining_polys[irpoly]];</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;      remaining_polys_cellID[irpoly] = cur_polys_cellID[iremaining_polys[irpoly]];</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    }</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <span class="keyword">delete</span> [] lower_hp_polys;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    cur_r2d_polys = remaining_polys;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    cur_polys_cellID = remaining_polys_cellID;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    cur_polys_moments = remaining_polys_moments;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  }</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  <span class="comment">//Poly&#39;s that are left after all lines were processed make up the circle</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;    <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;      std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                cells_mat_ids[icell].end(), material_IDs[1]));</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;      cells_mat_ids[icell].push_back(material_IDs[1]);</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;      cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;      <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        (*reference_mat_polys)[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;    }</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;    <span class="keywordflow">if</span> (reference_mat_polys != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;      (*reference_mat_polys)[icell][cell_mat_id].push_back(cur_r2d_polys[ipoly]);</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;      cells_mat_moments[icell][cell_mat_id][im] += cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;  }</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;  <span class="keyword">delete</span> [] cur_r2d_polys;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;  cell_num_mats.resize(ncells);</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  cell_mat_ids.clear();</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;  cell_mat_volfracs.clear();</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  cell_mat_centroids.clear();</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    cell_num_mats[icell] = cells_mat_ids[icell].size();</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    cell_mat_ids.insert(cell_mat_ids.end(), cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                        cells_mat_ids[icell].end());</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    <span class="keywordtype">int</span> offset = cell_mat_volfracs.size();</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    cell_mat_volfracs.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    cell_mat_centroids.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;    <span class="keywordtype">double</span> cell_volume = mesh.cell_volume(icell);</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> imat = 0; imat &lt; cell_num_mats[icell]; imat++) {</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;      cell_mat_volfracs[offset + imat] = </div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        cells_mat_moments[icell][imat][0]/cell_volume;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 2; idim++)</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;        cell_mat_centroids[offset + imat][idim] = </div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;          cells_mat_moments[icell][imat][idim + 1]/cells_mat_moments[icell][imat][0];</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;    }</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  }</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;}</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="preprocessor">#endif</span></div><div class="ttc" id="namespaceTangram_html_a4a082d6df64712201cc18e4a3228eecc"><div class="ttname"><a href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">Tangram::cell_get_matpoly</a></div><div class="ttdeci">void cell_get_matpoly(const Mesh_Wrapper &amp;Mesh, const int cellid, MatPoly&lt; 2 &gt; *mat_poly, const double dst_tol)</div><div class="ttdoc">Initializes a material polygon that corresponds to (i.e. has the same geometry as) a given mesh cell...</div><div class="ttdef"><b>Definition:</b> MatPoly.h:746</div></div>
<div class="ttc" id="r3d_8h_html_ae591f11a646bffc0b497ba6d440f326a"><div class="ttname"><a href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a></div><div class="ttdeci">void r3d_reduce(r3d_poly *poly, r3d_real *moments, r3d_int polyorder)</div></div>
<div class="ttc" id="primitives_8h_html"><div class="ttname"><a href="primitives_8h.html">primitives.h</a></div></div>
<div class="ttc" id="structr3d__plane_html_a82422a38dd2d1975d11d9d0ca6172027"><div class="ttname"><a href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">r3d_plane::d</a></div><div class="ttdeci">r3d_real d</div><div class="ttdef"><b>Definition:</b> r3d.h:79</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a3a65db5622231e4086244ad25ab6288d"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">Tangram::MatPoly::decompose</a></div><div class="ttdeci">void decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Decomposes this MatPoly into MatPoly&amp;#39;s using its centroid. If faces of MatPoly are planar...</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a8e814a40956aee6c5ade0c20abefe920"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">Tangram::MatPoly::facetize_decompose</a></div><div class="ttdeci">void facetize_decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Facetizes and decomposes this MatPoly into simplex MatPoly&amp;#39;s using its centroid. </div></div>
<div class="ttc" id="structr3d__plane_html_a6447f761d2c41d040a0fbdaa8e2885b1"><div class="ttname"><a href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">r3d_plane::n</a></div><div class="ttdeci">r3d_rvec3 n</div><div class="ttdef"><b>Definition:</b> r3d.h:78</div></div>
<div class="ttc" id="structr2d__plane_html_aab3829f60a24bbfe6af8ba1d237e7935"><div class="ttname"><a href="structr2d__plane.html#aab3829f60a24bbfe6af8ba1d237e7935">r2d_plane::n</a></div><div class="ttdeci">r2d_rvec2 n</div><div class="ttdef"><b>Definition:</b> r2d.h:81</div></div>
<div class="ttc" id="r3d_8h_html_a3aa887a1c16c46e933b08d25625aa024"><div class="ttname"><a href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a></div><div class="ttdeci">int32_t r3d_int</div><div class="ttdoc">Integer types used for indexing. </div><div class="ttdef"><b>Definition:</b> r3d.h:47</div></div>
<div class="ttc" id="cuts_8h_html_af4145e83e4fe14c7e3a657eafca5c939"><div class="ttname"><a href="cuts_8h.html#af4145e83e4fe14c7e3a657eafca5c939">finalize_ref_data</a></div><div class="ttdeci">void finalize_ref_data(const Mesh_Wrapper &amp;mesh, const std::vector&lt; std::vector&lt; std::shared_ptr&lt; RefPolyData_t &gt; &gt; &gt; &amp;ref_sets_data, const std::vector&lt; int &gt; &amp;sets_material_IDs, std::vector&lt; int &gt; &amp;cell_num_mats, std::vector&lt; int &gt; &amp;cell_mat_ids, std::vector&lt; double &gt; &amp;cell_mat_volfracs, std::vector&lt; Tangram::Point&lt; 3 &gt; &gt; &amp;cell_mat_centroids, const double dst_tol, const bool decompose_cells, std::vector&lt; std::vector&lt; std::vector&lt; r3d_poly &gt; &gt; &gt; *reference_mat_polys=nullptr)</div><div class="ttdoc">For a given collections of single-material reference polyhedra sets generates data compatible with Ta...</div><div class="ttdef"><b>Definition:</b> cuts.h:533</div></div>
<div class="ttc" id="r2d_8h_html_a7051e2a3074dcda55d4ffe56a31c910c"><div class="ttname"><a href="r2d_8h.html#a7051e2a3074dcda55d4ffe56a31c910c">r2d_real</a></div><div class="ttdeci">double r2d_real</div><div class="ttdoc">Real type specifying the precision to be used in calculations. </div><div class="ttdef"><b>Definition:</b> r2d.h:46</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a5f2c01d5edefa8331e146b12d0cc2f4e"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a5f2c01d5edefa8331e146b12d0cc2f4e">Tangram::MatPoly::initialize</a></div><div class="ttdeci">void initialize(const std::vector&lt; Point2 &gt; &amp;poly_points, const double dst_tol)</div><div class="ttdoc">Initialize a 2D polygon from its vertices. </div></div>
<div class="ttc" id="structr2d__poly_html"><div class="ttname"><a href="structr2d__poly.html">r2d_poly</a></div><div class="ttdoc">A polygon. Can be convex, nonconvex, even multiply-connected. </div><div class="ttdef"><b>Definition:</b> r2d.h:96</div></div>
<div class="ttc" id="r3d_8h_html_aa30ff2c6771668f327e1b0e4bd5cb58f"><div class="ttname"><a href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a></div><div class="ttdeci">double r3d_real</div><div class="ttdoc">Real type specifying the precision to be used in calculations. </div><div class="ttdef"><b>Definition:</b> r3d.h:41</div></div>
<div class="ttc" id="cuts_8h_html"><div class="ttname"><a href="cuts_8h.html">cuts.h</a></div></div>
<div class="ttc" id="unionr2d__rvec2_html_ad9a1cfdc5716855be5fff46ff18550e4"><div class="ttname"><a href="unionr2d__rvec2.html#ad9a1cfdc5716855be5fff46ff18550e4">r2d_rvec2::xy</a></div><div class="ttdeci">r2d_real xy[2]</div><div class="ttdef"><b>Definition:</b> r2d.h:63</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html"><div class="ttname"><a href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt; 3 &gt;</a></div></div>
<div class="ttc" id="structr2d__plane_html_a51f453b0f5dc7ec389fc33d46886f0d6"><div class="ttname"><a href="structr2d__plane.html#a51f453b0f5dc7ec389fc33d46886f0d6">r2d_plane::d</a></div><div class="ttdeci">r2d_real d</div><div class="ttdef"><b>Definition:</b> r2d.h:82</div></div>
<div class="ttc" id="namespaceTangram_html_a2364ea47380698d6b380574978c068da"><div class="ttname"><a href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">Tangram::matpoly_to_r3dpoly</a></div><div class="ttdeci">void matpoly_to_r3dpoly(const MatPoly&lt; 3 &gt; &amp;mat_poly, r3d_poly &amp;r3dpoly)</div><div class="ttdoc">Converts a MatPoly to a polyhedron in R3D format. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:41</div></div>
<div class="ttc" id="classTangram_1_1Point_html"><div class="ttname"><a href="classTangram_1_1Point.html">Tangram::Point</a></div><div class="ttdoc">Represents a point in an N-dimensional space. </div><div class="ttdef"><b>Definition:</b> Point.h:48</div></div>
<div class="ttc" id="namespaceTangram_html_ae282114f99c97df0c59c6006bc065e0b"><div class="ttname"><a href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">Tangram::matpoly_to_r2dpoly</a></div><div class="ttdeci">void matpoly_to_r2dpoly(const MatPoly&lt; 2 &gt; &amp;mat_poly, r2d_poly &amp;r2dpoly)</div><div class="ttdoc">Converts a MatPoly to a polygon in R2D format. </div><div class="ttdef"><b>Definition:</b> split_r2d.h:71</div></div>
<div class="ttc" id="split__r2d_8h_html"><div class="ttname"><a href="split__r2d_8h.html">split_r2d.h</a></div><div class="ttdoc">Routines for splitting convex or non-convex MatPoly&amp;#39;s by a cutting plane. Uses R2D. A convex MatPoly will be split into two MatPoly&amp;#39;s. A non-convex MatPoly will be decomposed into convex polyhedra using its centroid, several MatPoly&amp;#39;s could be returned for each half-plane. All the faces of the input MatPoly are assumed to be planar and no additional facetization is performed, so when sequentially splitting of a faceted MatPoly, no additional facets will be introduced. </div></div>
<div class="ttc" id="primitives_8h_html_a299aabc5fc8285cbf99025330a3d0d0d"><div class="ttname"><a href="primitives_8h.html#a299aabc5fc8285cbf99025330a3d0d0d">PI</a></div><div class="ttdeci">constexpr double PI</div><div class="ttdef"><b>Definition:</b> primitives.h:28</div></div>
<div class="ttc" id="tangram_8h_html"><div class="ttname"><a href="tangram_8h.html">tangram.h</a></div></div>
<div class="ttc" id="r2d_8h_html_a0ca3136f66f864d6bb8dddb2d588c349"><div class="ttname"><a href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a></div><div class="ttdeci">void r2d_reduce(r2d_poly *poly, r2d_real *moments, r2d_int polyorder)</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html"><div class="ttname"><a href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt; 3 &gt;</a></div></div>
<div class="ttc" id="structr3d__plane_html"><div class="ttname"><a href="structr3d__plane.html">r3d_plane</a></div><div class="ttdef"><b>Definition:</b> r3d.h:76</div></div>
<div class="ttc" id="structr2d__plane_html"><div class="ttname"><a href="structr2d__plane.html">r2d_plane</a></div><div class="ttdoc">A plane. </div><div class="ttdef"><b>Definition:</b> r2d.h:80</div></div>
<div class="ttc" id="cuts_8h_html_ada8f3f960ae9834b492be70f14ca85fa"><div class="ttname"><a href="cuts_8h.html#ada8f3f960ae9834b492be70f14ca85fa">apply_poly</a></div><div class="ttdeci">void apply_poly(const std::vector&lt; std::shared_ptr&lt; RefPolyData_t &gt; &gt; &amp;polys_data, const Tangram::MatPoly&lt; 3 &gt; &amp;mat_poly, std::vector&lt; std::shared_ptr&lt; RefPolyData_t &gt; &gt; &amp;interior_data, std::vector&lt; std::shared_ptr&lt; RefPolyData_t &gt; &gt; &amp;exterior_data, const double vol_tol, const double dst_tol, const bool convex_matpoly)</div><div class="ttdoc">Generates data for polyhedra inside and outside of a given shape. Can use multiple threads...</div><div class="ttdef"><b>Definition:</b> cuts.h:405</div></div>
<div class="ttc" id="r2d_8h_html_a4e28f6b07d5799645b1590201dc20b69"><div class="ttname"><a href="r2d_8h.html#a4e28f6b07d5799645b1590201dc20b69">r2d_split</a></div><div class="ttdeci">void r2d_split(r2d_poly *inpolys, r2d_int npolys, r2d_plane plane, r2d_poly *out_pos, r2d_poly *out_neg)</div><div class="ttdoc">Splits a list of polygons across a single plane. </div></div>
<div class="ttc" id="structr3d__poly_html"><div class="ttname"><a href="structr3d__poly.html">r3d_poly</a></div><div class="ttdef"><b>Definition:</b> r3d.h:93</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_aba885f75525c109661a08cb41a413a5b"><div class="ttname"><a href="classTangram_1_1MatPoly.html#aba885f75525c109661a08cb41a413a5b">Tangram::MatPoly::face_planes</a></div><div class="ttdeci">void face_planes(std::vector&lt; Plane_t&lt; D &gt; &gt; &amp;fplanes) const</div><div class="ttdoc">For every face, returns a plane containing that face. Important: faces should be planar, so you might need to facetize the MatPoly first. In 2D, faces of size below the distance tolerance will be omitted. In 3D, faces should have at least three edges of size above the distance tolerance. If the number of valid planes is less than four, empty vector will be returned. </div></div>
<div class="ttc" id="r2d_8h_html_a40c43d55f6372345f355d5f34eb919c5"><div class="ttname"><a href="r2d_8h.html#a40c43d55f6372345f355d5f34eb919c5">r2d_int</a></div><div class="ttdeci">int32_t r2d_int</div><div class="ttdoc">Integer types used for indexing. </div><div class="ttdef"><b>Definition:</b> r2d.h:52</div></div>
<div class="ttc" id="unionr3d__rvec3_html_ab127c0310533e3caaafcad80b7280fe1"><div class="ttname"><a href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">r3d_rvec3::xyz</a></div><div class="ttdeci">r3d_real xyz[3]</div><div class="ttdef"><b>Definition:</b> r3d.h:59</div></div>
<div class="ttc" id="primitives_8h_html_a39487a4df0863383e76a5cfae81bff5e"><div class="ttname"><a href="primitives_8h.html#a39487a4df0863383e76a5cfae81bff5e">sphere</a></div><div class="ttdeci">Tangram::MatPoly&lt; 3 &gt; sphere(const Tangram::Point3 &amp;center, double radius, int nquadrant_samples, double dst_tol)</div><div class="ttdoc">Generates a faceted sphere. </div><div class="ttdef"><b>Definition:</b> primitives.h:365</div></div>
<div class="ttc" id="r3d_8h_html_ace7c6f2c67e44a0a24c13f4cd1dbf138"><div class="ttname"><a href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a></div><div class="ttdeci">#define R3D_NUM_MOMENTS(order)</div><div class="ttdoc">Integrate a polynomial density over a polyhedron using simplicial decomposition. Uses the fast recurs...</div><div class="ttdef"><b>Definition:</b> r3d.h:154</div></div>
<div class="ttc" id="r2d_8h_html_abb06105c9ba90a0af19b4a5104c8ccc0"><div class="ttname"><a href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a></div><div class="ttdeci">#define R2D_NUM_MOMENTS(order)</div><div class="ttdoc">Integrate a polynomial density over a polygon using simplicial decomposition. Uses the fast recursive...</div><div class="ttdef"><b>Definition:</b> r2d.h:160</div></div>
<div class="ttc" id="r3d_8h_html_aad337c9fbabbd571b25490c27f3709d9"><div class="ttname"><a href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a></div><div class="ttdeci">void r3d_split(r3d_poly *inpolys, r3d_int npolys, r3d_plane plane, r3d_poly *out_pos, r3d_poly *out_neg)</div><div class="ttdoc">Splits a list of polyhedra across a single plane. </div></div>
<div class="ttc" id="get__material__moments_8h_html_abbedb07ff3211a44c8887492cbd3be0e"><div class="ttname"><a href="get__material__moments_8h.html#abbedb07ff3211a44c8887492cbd3be0e">get_material_moments</a></div><div class="ttdeci">void get_material_moments(const Mesh_Wrapper &amp;mesh, const std::vector&lt; Tangram::Plane_t&lt; 3 &gt; &gt; &amp;planar_interfaces, const std::vector&lt; int &gt; &amp;material_IDs, std::vector&lt; int &gt; &amp;cell_num_mats, std::vector&lt; int &gt; &amp;cell_mat_ids, std::vector&lt; double &gt; &amp;cell_mat_volfracs, std::vector&lt; Tangram::Point&lt; 3 &gt; &gt; &amp;cell_mat_centroids, const double vol_tol, const double dst_tol, const bool decompose_cells, std::vector&lt; std::vector&lt; std::vector&lt; r3d_poly &gt; &gt; &gt; *reference_mat_polys=nullptr)</div><div class="ttdoc">For a given mesh and a sequence of planes computes volume fractions and centroids. r3d is used to compute intersection moments. For every plane in the sequence, the remaining parts of the domain in the lower half-space are assigned the corresponding material and excluded from further consideration. </div><div class="ttdef"><b>Definition:</b> get_material_moments.h:44</div></div>
<div class="ttc" id="namespaceTangram_html_a71c39deca72d48990415ee231a9170b1"><div class="ttname"><a href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">Tangram::vector</a></div><div class="ttdeci">std::vector&lt; T &gt; vector</div><div class="ttdef"><b>Definition:</b> tangram.h:138</div></div>
<div class="ttc" id="split__r3d_8h_html"><div class="ttname"><a href="split__r3d_8h.html">split_r3d.h</a></div><div class="ttdoc">Routines for splitting convex or non-convex MatPoly&amp;#39;s by a cutting plane. Uses R3D. A convex MatPoly will be split into two MatPoly&amp;#39;s. A non-convex MatPoly will be decomposed into convex polyhedra using its centroid, several MatPoly&amp;#39;s could be returned for each half-plane. All the faces of the input MatPoly are assumed to be planar and no additional facetization is performed, so when sequentially splitting of a faceted MatPoly, no additional facets will be introduced. </div></div>
</div><!-- fragment --></div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
