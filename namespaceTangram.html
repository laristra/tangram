<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>tangram: Tangram Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Tangram Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1ClipR2D.html">ClipR2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1ClipR3D.html">ClipR3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1CuttingDistanceSolver.html">CuttingDistanceSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1Driver.html">Driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTangram_1_1Driver.html" title="Driver provides the API for reconstructing interfaces in multimaterial cells and answering queries ab...">Driver</a> provides the API for reconstructing interfaces in multimaterial cells and answering queries about said interfaces.  <a href="classTangram_1_1Driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTangram_1_1HalfSpaceSets__t.html">HalfSpaceSets_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTangram_1_1MatPolySet__t.html">MatPolySet_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html">MOF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1NestedDissections.html">NestedDissections</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a point in an N-dimensional space.  <a href="classTangram_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1SLIC.html">SLIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the interface and constructs <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> for the <a class="el" href="classTangram_1_1SLIC.html" title="Calculates the interface and constructs CellMatPoly for the SLIC algorithm. ">SLIC</a> algorithm.  <a href="classTangram_1_1SLIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1SplitR2D.html">SplitR2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1SplitR3D.html">SplitR3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a vector in N-dimensional space.  <a href="classTangram_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1VOF.html">VOF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1XMOF2D__Wrapper.html">XMOF2D_Wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates material interfaces and constructs <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> objects for specified cells using the eXtended Moments-of-Fluid (X-MOF) method.  <a href="classTangram_1_1XMOF2D__Wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0d7f6faf100a226eee664d64ef9f725a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a></td></tr>
<tr class="memdesc:a0d7f6faf100a226eee664d64ef9f725a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 3d.  <a href="#a0d7f6faf100a226eee664d64ef9f725a">More...</a><br /></td></tr>
<tr class="separator:a0d7f6faf100a226eee664d64ef9f725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7fb85e2d6b6347abfb97f1d8179f50"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Point2</a></td></tr>
<tr class="memdesc:a0d7fb85e2d6b6347abfb97f1d8179f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 2d.  <a href="#a0d7fb85e2d6b6347abfb97f1d8179f50">More...</a><br /></td></tr>
<tr class="separator:a0d7fb85e2d6b6347abfb97f1d8179f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d2c7fff87afc3f9895cdbfcbb2118"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a507d2c7fff87afc3f9895cdbfcbb2118">Point1</a></td></tr>
<tr class="memdesc:a507d2c7fff87afc3f9895cdbfcbb2118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 1d.  <a href="#a507d2c7fff87afc3f9895cdbfcbb2118">More...</a><br /></td></tr>
<tr class="separator:a507d2c7fff87afc3f9895cdbfcbb2118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c5f2df8e30ec231f93a541c55d994"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a206c5f2df8e30ec231f93a541c55d994"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a206c5f2df8e30ec231f93a541c55d994">Point</a> = Wonton::Point&lt; D &gt;</td></tr>
<tr class="separator:a206c5f2df8e30ec231f93a541c55d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a44825ec386d2499b8ef8c3c1de5c72"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a4a44825ec386d2499b8ef8c3c1de5c72"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a4a44825ec386d2499b8ef8c3c1de5c72">Vector</a> = Wonton::Vector&lt; D &gt;</td></tr>
<tr class="separator:a4a44825ec386d2499b8ef8c3c1de5c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c39deca72d48990415ee231a9170b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71c39deca72d48990415ee231a9170b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">vector</a> = std::vector&lt; T &gt;</td></tr>
<tr class="separator:a71c39deca72d48990415ee231a9170b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e628a70cff126b7d2d71b8143c81ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40e628a70cff126b7d2d71b8143c81ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a40e628a70cff126b7d2d71b8143c81ee">pointer</a> = std::shared_ptr&lt; T &gt;</td></tr>
<tr class="separator:a40e628a70cff126b7d2d71b8143c81ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625f11731b081a330f8829a6a4cb7656"><td class="memItemLeft" align="right" valign="top">typedef boost::counting_iterator&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a625f11731b081a330f8829a6a4cb7656">counting_iterator</a></td></tr>
<tr class="separator:a625f11731b081a330f8829a6a4cb7656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283ae03606aa1f9e34f6f87d7cbb287e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a283ae03606aa1f9e34f6f87d7cbb287e">Vector3</a></td></tr>
<tr class="memdesc:a283ae03606aa1f9e34f6f87d7cbb287e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for creating a 3D vector.  <a href="#a283ae03606aa1f9e34f6f87d7cbb287e">More...</a><br /></td></tr>
<tr class="separator:a283ae03606aa1f9e34f6f87d7cbb287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d69e9ce03789cdf1605ac0dc93f92e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aa6d69e9ce03789cdf1605ac0dc93f92e">Vector2</a></td></tr>
<tr class="memdesc:aa6d69e9ce03789cdf1605ac0dc93f92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for creating a 3D vector.  <a href="#aa6d69e9ce03789cdf1605ac0dc93f92e">More...</a><br /></td></tr>
<tr class="separator:aa6d69e9ce03789cdf1605ac0dc93f92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acbc93a9c17403e5d2e10e53fb002d1b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3">BFGS_ALG</a> { <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3a69c8d5b5c7c91d37e9c7e05fae6d0f86">BFGS</a>, 
<a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3a31463a1a03f66e2d5728a58df0c91305">DBFGS</a>
 }</td></tr>
<tr class="separator:acbc93a9c17403e5d2e10e53fb002d1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4eca4fe70b7096799ce9a4717b0457a"><td class="memTemplParams" colspan="2">template&lt;class Mesh_Wrapper , int D&gt; </td></tr>
<tr class="memitem:ae4eca4fe70b7096799ce9a4717b0457a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ae4eca4fe70b7096799ce9a4717b0457a">write_to_gmv</a> (Mesh_Wrapper const &amp;mesh, int nmats, std::vector&lt; int &gt; const &amp;cell_num_mats, std::vector&lt; int &gt; const &amp;cell_mat_ids, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt; D &gt;&gt;&gt; cellmatpoly_list, std::string filename)</td></tr>
<tr class="separator:ae4eca4fe70b7096799ce9a4717b0457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08829fb30da7bfef5b1d182ce2e6c820"><td class="memTemplParams" colspan="2">template&lt;int D&gt; </td></tr>
<tr class="memitem:a08829fb30da7bfef5b1d182ce2e6c820"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a08829fb30da7bfef5b1d182ce2e6c820">write_to_gmv</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt; D &gt;&gt;&gt; &amp;cellmatpoly_list, const std::string &amp;filename)</td></tr>
<tr class="separator:a08829fb30da7bfef5b1d182ce2e6c820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7012e7bb1d6b908e25f8426430e11de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a7012e7bb1d6b908e25f8426430e11de2">r2dpoly_to_matpoly</a> (const <a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;r2dpoly, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;mat_poly, const double dst_tol, const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; *reference_pts=nullptr)</td></tr>
<tr class="memdesc:a7012e7bb1d6b908e25f8426430e11de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a R2D poly to a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> where the vertices in the Matpoly are ordered counter clock-wise.  <a href="#a7012e7bb1d6b908e25f8426430e11de2">More...</a><br /></td></tr>
<tr class="separator:a7012e7bb1d6b908e25f8426430e11de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282114f99c97df0c59c6006bc065e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">matpoly_to_r2dpoly</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;mat_poly, <a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;r2dpoly)</td></tr>
<tr class="memdesc:ae282114f99c97df0c59c6006bc065e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to a polygon in R2D format.  <a href="#ae282114f99c97df0c59c6006bc065e0b">More...</a><br /></td></tr>
<tr class="separator:ae282114f99c97df0c59c6006bc065e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c203c6b6098cf8d1a6aaa44f6129c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a76c203c6b6098cf8d1a6aaa44f6129c1">get_intersection_moments</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;mat_poly, const <a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;r2dpoly, std::vector&lt; double &gt; &amp;intersection_moments, bool convex_matpoly)</td></tr>
<tr class="memdesc:a76c203c6b6098cf8d1a6aaa44f6129c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes moments of the intersection of a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> and an <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a>. If <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex, <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a> will be clipped with lines containing the faces of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>. Otherwise, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> will be decomposed into triangular MatPolys, each of which will be intersected with <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a>. Note that <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a> does not need to be convex.  <a href="#a76c203c6b6098cf8d1a6aaa44f6129c1">More...</a><br /></td></tr>
<tr class="separator:a76c203c6b6098cf8d1a6aaa44f6129c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5551f71f2e6bd3082c4f9756d55d9f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a5551f71f2e6bd3082c4f9756d55d9f33">split_convex_matpoly_r2d</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;mat_poly, const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; 2 &gt; &amp;cutting_plane, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;lower_halfspace_poly, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;upper_halfspace_poly, std::vector&lt; double &gt; &amp;lower_halfspace_moments, std::vector&lt; double &gt; &amp;upper_halfspace_moments, double vol_tol, double dst_tol)</td></tr>
<tr class="memdesc:a5551f71f2e6bd3082c4f9756d55d9f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> into two (convex) <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s with a cutting plane.  <a href="#a5551f71f2e6bd3082c4f9756d55d9f33">More...</a><br /></td></tr>
<tr class="separator:a5551f71f2e6bd3082c4f9756d55d9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2364ea47380698d6b380574978c068da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">matpoly_to_r3dpoly</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;mat_poly, <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;r3dpoly)</td></tr>
<tr class="memdesc:a2364ea47380698d6b380574978c068da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to a polyhedron in R3D format.  <a href="#a2364ea47380698d6b380574978c068da">More...</a><br /></td></tr>
<tr class="separator:a2364ea47380698d6b380574978c068da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43906bb61091453a4fc320c983f9c733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a43906bb61091453a4fc320c983f9c733">r3d_poly_components</a> (const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;r3dpoly, std::vector&lt; <a class="el" href="structr3d__poly.html">r3d_poly</a> &gt; &amp;poly_components, const double vol_tol)</td></tr>
<tr class="memdesc:a43906bb61091453a4fc320c983f9c733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks an <a class="el" href="structr3d__poly.html">r3d_poly</a> into a vector of disjoint components.  <a href="#a43906bb61091453a4fc320c983f9c733">More...</a><br /></td></tr>
<tr class="separator:a43906bb61091453a4fc320c983f9c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8da5e3ebb9e36f354b8d4351050c246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ac8da5e3ebb9e36f354b8d4351050c246">r3dpoly_to_matpolys</a> (const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;r3dpoly, std::vector&lt; <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &gt; &amp;mat_polys, const double vol_tol, const double dst_tol, const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &gt; *reference_pts=nullptr)</td></tr>
<tr class="memdesc:ac8da5e3ebb9e36f354b8d4351050c246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a polyhedron in R3D format to <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s.  <a href="#ac8da5e3ebb9e36f354b8d4351050c246">More...</a><br /></td></tr>
<tr class="separator:ac8da5e3ebb9e36f354b8d4351050c246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d36b5dbc71670d73c1b6d326fa81a85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a8d36b5dbc71670d73c1b6d326fa81a85">split_convex_matpoly_r3d</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;mat_poly, const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; 3 &gt; &amp;cutting_plane, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;lower_halfspace_poly, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;upper_halfspace_poly, std::vector&lt; double &gt; &amp;lower_halfspace_moments, std::vector&lt; double &gt; &amp;upper_halfspace_moments, double vol_tol, double dst_tol)</td></tr>
<tr class="memdesc:a8d36b5dbc71670d73c1b6d326fa81a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> into two (convex) <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s with a cutting plane.  <a href="#a8d36b5dbc71670d73c1b6d326fa81a85">More...</a><br /></td></tr>
<tr class="separator:a8d36b5dbc71670d73c1b6d326fa81a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f943054dc7440e73891fa687911b14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a04f943054dc7440e73891fa687911b14">get_intersection_moments</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;mat_poly, const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;r3dpoly, std::vector&lt; double &gt; &amp;intersection_moments, bool convex_matpoly)</td></tr>
<tr class="memdesc:a04f943054dc7440e73891fa687911b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes moments of the intersection of a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> and an <a class="el" href="structr3d__poly.html">r3d_poly</a>. If <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex, <a class="el" href="structr3d__poly.html">r3d_poly</a> will be clipped with planes containing the faces of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>. Otherwise, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> will be decomposed into tetrahedral MatPolys, each of which will be intersected with <a class="el" href="structr3d__poly.html">r3d_poly</a>. Note that <a class="el" href="structr3d__poly.html">r3d_poly</a> does not need to be convex.  <a href="#a04f943054dc7440e73891fa687911b14">More...</a><br /></td></tr>
<tr class="separator:a04f943054dc7440e73891fa687911b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a989a601d36db6dab4fcec22ed85fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a76a989a601d36db6dab4fcec22ed85fe">r3d_poly_bounding_box</a> (const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;r3dpoly)</td></tr>
<tr class="separator:a76a989a601d36db6dab4fcec22ed85fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb672bd64174fd73fc2854ab52e0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a89fb672bd64174fd73fc2854ab52e0c3">cartesian_to_polar</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; cartesian_vec)</td></tr>
<tr class="separator:a89fb672bd64174fd73fc2854ab52e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0962fe321eb5d6aebe45bc5c7758840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ad0962fe321eb5d6aebe45bc5c7758840">cartesian_to_polar</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt; cartesian_vec)</td></tr>
<tr class="separator:ad0962fe321eb5d6aebe45bc5c7758840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d180681d4c78fd3288902c7101a91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a59d180681d4c78fd3288902c7101a91a">polar_to_cartesian</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt; polar_vec)</td></tr>
<tr class="separator:a59d180681d4c78fd3288902c7101a91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0b6a408ae03bac84775e2a263a7e7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ade0b6a408ae03bac84775e2a263a7e7a">polar_to_cartesian</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; polar_vec)</td></tr>
<tr class="separator:ade0b6a408ae03bac84775e2a263a7e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a22f853981042ff40dbe7bed31dc17"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a74a22f853981042ff40dbe7bed31dc17">quad_interpolant_minimizer</a> (const double arg0, const double arg1, const double fval0, const double fval1, const double df0, const double *safeguards)</td></tr>
<tr class="memdesc:a74a22f853981042ff40dbe7bed31dc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimizer of a quadratic interpolant in the interval.  <a href="#a74a22f853981042ff40dbe7bed31dc17">More...</a><br /></td></tr>
<tr class="separator:a74a22f853981042ff40dbe7bed31dc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19d39ec7ebae38d35674f4e3630ddaa"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:ad19d39ec7ebae38d35674f4e3630ddaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ad19d39ec7ebae38d35674f4e3630ddaa">fwd_diff_grad</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;fun, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;arg_val, const double &amp;fun_val, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;approx_grad, double &amp;fdiff_h)</td></tr>
<tr class="memdesc:ad19d39ec7ebae38d35674f4e3630ddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward finite difference approximation of a gradient.  <a href="#ad19d39ec7ebae38d35674f4e3630ddaa">More...</a><br /></td></tr>
<tr class="separator:ad19d39ec7ebae38d35674f4e3630ddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8686bea4d2f435f2546c28f8996b58"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:acc8686bea4d2f435f2546c28f8996b58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#acc8686bea4d2f435f2546c28f8996b58">cen_diff_grad</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;fun, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;arg_val, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;approx_grad, double &amp;fdiff_h)</td></tr>
<tr class="memdesc:acc8686bea4d2f435f2546c28f8996b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Central finite difference approximation of a gradient.  <a href="#acc8686bea4d2f435f2546c28f8996b58">More...</a><br /></td></tr>
<tr class="separator:acc8686bea4d2f435f2546c28f8996b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b5db50aff69e0d2ff71bf6c6d79aa7"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:ac0b5db50aff69e0d2ff71bf6c6d79aa7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ac0b5db50aff69e0d2ff71bf6c6d79aa7">finite_diff_grad</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;fun, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;arg_val, const double &amp;fun_val, const double rel_err_bnd, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;approx_grad)</td></tr>
<tr class="memdesc:ac0b5db50aff69e0d2ff71bf6c6d79aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite difference approximation of a gradient. Switches from forward to central finite differences if the value of the gradient is not significant relative to the method's error.  <a href="#ac0b5db50aff69e0d2ff71bf6c6d79aa7">More...</a><br /></td></tr>
<tr class="separator:ac0b5db50aff69e0d2ff71bf6c6d79aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f74efa496fa4e1c06b3e39a788ee78"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:a89f74efa496fa4e1c06b3e39a788ee78"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a89f74efa496fa4e1c06b3e39a788ee78">linesearch</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;obj_fun, const double &amp;obj_fun_lbnd, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;arg, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;dir, const double &amp;initial_guess, const double &amp;c1, const double &amp;c2, const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;im_tols, const double rel_err_bnd, double &amp;cur_fval, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;cur_grad)</td></tr>
<tr class="memdesc:a89f74efa496fa4e1c06b3e39a788ee78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linesearch algorithm: finds the argument satisfying the strong Wolfe conditions.  <a href="#a89f74efa496fa4e1c06b3e39a788ee78">More...</a><br /></td></tr>
<tr class="separator:a89f74efa496fa4e1c06b3e39a788ee78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed879b10eb7c556f505cdaa29bcf0b3"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:a0ed879b10eb7c556f505cdaa29bcf0b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a0ed879b10eb7c556f505cdaa29bcf0b3">bfgs</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;obj_fun, const double &amp;obj_fun_lbnd, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;init_guess, const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;im_tols)</td></tr>
<tr class="memdesc:a0ed879b10eb7c556f505cdaa29bcf0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">BFGS algorithm: finds the minimizer of the objective function.  <a href="#a0ed879b10eb7c556f505cdaa29bcf0b3">More...</a><br /></td></tr>
<tr class="separator:a0ed879b10eb7c556f505cdaa29bcf0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b16d21c00e552fb22347aec9c972a6"><td class="memTemplParams" colspan="2">template&lt;int arg_dim&gt; </td></tr>
<tr class="memitem:a22b16d21c00e552fb22347aec9c972a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a22b16d21c00e552fb22347aec9c972a6">dbfgs</a> (const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;obj_fun, const double &amp;obj_fun_lbnd, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;init_guess, const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;im_tols)</td></tr>
<tr class="memdesc:a22b16d21c00e552fb22347aec9c972a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">D-BFGS algorithm: finds the minimizer of the objective function Based on "Improved Damped Quasi-Newton Methods for Unconstrained Optimization" by Mehiddin Al-Baali and Lucio Grandinetti, Pacific Journal of Optimization (to appear).  <a href="#a22b16d21c00e552fb22347aec9c972a6">More...</a><br /></td></tr>
<tr class="separator:a22b16d21c00e552fb22347aec9c972a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef97752fc2daf4936063c41dbbc9abd"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:afef97752fc2daf4936063c41dbbc9abd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#afef97752fc2daf4936063c41dbbc9abd">ls_gradient</a> (std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&gt; const &amp;coords, std::vector&lt; double &gt; const &amp;vals)</td></tr>
<tr class="memdesc:afef97752fc2daf4936063c41dbbc9abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute least squares gradient from set of values.  <a href="#afef97752fc2daf4936063c41dbbc9abd">More...</a><br /></td></tr>
<tr class="separator:afef97752fc2daf4936063c41dbbc9abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add95776fd9a423b220c590e28f32fd22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#add95776fd9a423b220c590e28f32fd22">polygon3d_area</a> (const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, double dst_tol)</td></tr>
<tr class="separator:add95776fd9a423b220c590e28f32fd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0379ce04695d2beacee8173ab40f62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aa0379ce04695d2beacee8173ab40f62b">polygon3d_moments</a> (const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, std::vector&lt; double &gt; &amp;poly_moments, double dst_tol)</td></tr>
<tr class="separator:aa0379ce04695d2beacee8173ab40f62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498a02ba72d13092913c9ac3d5a7f8b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a498a02ba72d13092913c9ac3d5a7f8b2">polygon3d_normal</a> (const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;points, const std::vector&lt; int &gt; &amp;poly_vertices, double dst_tol)</td></tr>
<tr class="separator:a498a02ba72d13092913c9ac3d5a7f8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a082d6df64712201cc18e4a3228eecc"><td class="memTemplParams" colspan="2">template&lt;class Mesh_Wrapper &gt; </td></tr>
<tr class="memitem:a4a082d6df64712201cc18e4a3228eecc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a4a082d6df64712201cc18e4a3228eecc">cell_get_matpoly</a> (const Mesh_Wrapper &amp;Mesh, const int cellid, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; *mat_poly, const double dst_tol)</td></tr>
<tr class="memdesc:a4a082d6df64712201cc18e4a3228eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a material polygon that corresponds to (i.e. has the same geometry as) a given mesh cell.  <a href="#a4a082d6df64712201cc18e4a3228eecc">More...</a><br /></td></tr>
<tr class="separator:a4a082d6df64712201cc18e4a3228eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e78b490c82464a056ec64a36ee2e387"><td class="memTemplParams" colspan="2">template&lt;class Mesh_Wrapper &gt; </td></tr>
<tr class="memitem:a0e78b490c82464a056ec64a36ee2e387"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a0e78b490c82464a056ec64a36ee2e387">cell_get_matpoly</a> (const Mesh_Wrapper &amp;Mesh, const int cellid, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; *mat_poly, const double dst_tol)</td></tr>
<tr class="memdesc:a0e78b490c82464a056ec64a36ee2e387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a material polyhedron that corresponds to (i.e. has the same geometry as) a given mesh cell.  <a href="#a0e78b490c82464a056ec64a36ee2e387">More...</a><br /></td></tr>
<tr class="separator:a0e78b490c82464a056ec64a36ee2e387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69297ec3a4d9448be375b217d7297fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a69297ec3a4d9448be375b217d7297fe9">natural_selection</a> (const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; &amp;poly_points, const double dst_tol, const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; *reference_pts=nullptr)</td></tr>
<tr class="memdesc:a69297ec3a4d9448be375b217d7297fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates degenerate faces from a polygon given by a sequence of vertices.  <a href="#a69297ec3a4d9448be375b217d7297fe9">More...</a><br /></td></tr>
<tr class="separator:a69297ec3a4d9448be375b217d7297fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf0201d875a729c2ab615434bf540e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a9cf0201d875a729c2ab615434bf540e5">natural_selection</a> (const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;vertex_points, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;face_vertices, const double dst_tol, const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &gt; *reference_pts=nullptr)</td></tr>
<tr class="memdesc:a9cf0201d875a729c2ab615434bf540e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates degeneracies from the boundary representation, which includes vertices within distance tolerance from other vertices, hanging nodes, and degenerate faces with less than three vertices.  <a href="#a9cf0201d875a729c2ab615434bf540e5">More...</a><br /></td></tr>
<tr class="separator:a9cf0201d875a729c2ab615434bf540e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9c97f69aeca40afb983ab4c229059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a06e9c97f69aeca40afb983ab4c229059">point_inside_matpoly</a> (const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; mat_poly, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &amp;pt, double dst_tol, bool convex_poly)</td></tr>
<tr class="memdesc:a06e9c97f69aeca40afb983ab4c229059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given point is interior wrt to a given polyhedron. Note: boundary points are no considered to be interior.  <a href="#a06e9c97f69aeca40afb983ab4c229059">More...</a><br /></td></tr>
<tr class="separator:a06e9c97f69aeca40afb983ab4c229059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01579d0f4681395bfdee1613d047b55"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ad01579d0f4681395bfdee1613d047b55">operator+</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="separator:ad01579d0f4681395bfdee1613d047b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38482a96ce72f503485a3955808503a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a38482a96ce72f503485a3955808503a0">operator-</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;B)</td></tr>
<tr class="memdesc:a38482a96ce72f503485a3955808503a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two materices.  <a href="#a38482a96ce72f503485a3955808503a0">More...</a><br /></td></tr>
<tr class="separator:a38482a96ce72f503485a3955808503a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65f42d8d4c6ad3e9f15de6b726a6f5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ac65f42d8d4c6ad3e9f15de6b726a6f5d">operator*</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const double &amp;s)</td></tr>
<tr class="memdesc:ac65f42d8d4c6ad3e9f15de6b726a6f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> by a scalar.  <a href="#ac65f42d8d4c6ad3e9f15de6b726a6f5d">More...</a><br /></td></tr>
<tr class="separator:ac65f42d8d4c6ad3e9f15de6b726a6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274802a8b305a6b25bda1228da151468"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a274802a8b305a6b25bda1228da151468">operator*</a> (const double &amp;s, const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a274802a8b305a6b25bda1228da151468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> by a scalar.  <a href="#a274802a8b305a6b25bda1228da151468">More...</a><br /></td></tr>
<tr class="separator:a274802a8b305a6b25bda1228da151468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeb9044b063e89a62f780a8493a97d3"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a1aeb9044b063e89a62f780a8493a97d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Matrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a1aeb9044b063e89a62f780a8493a97d3">operator*</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;b)</td></tr>
<tr class="separator:a1aeb9044b063e89a62f780a8493a97d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a6c3d59a5f65098fb653ed54cabfb"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a631a6c3d59a5f65098fb653ed54cabfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a631a6c3d59a5f65098fb653ed54cabfb">solve</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;b, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;x)</td></tr>
<tr class="memdesc:a631a6c3d59a5f65098fb653ed54cabfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the solution of A*x = b using the QR decomposition.  <a href="#a631a6c3d59a5f65098fb653ed54cabfb">More...</a><br /></td></tr>
<tr class="separator:a631a6c3d59a5f65098fb653ed54cabfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bb13e8a1a69429fa06a463d8c3071b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac3bb13e8a1a69429fa06a463d8c3071b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ac3bb13e8a1a69429fa06a463d8c3071b">solve&lt; 1 &gt;</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt; &amp;b, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt; &amp;x)</td></tr>
<tr class="memdesc:ac3bb13e8a1a69429fa06a463d8c3071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the solution of A*x = b for 1x1 algebraic system.  <a href="#ac3bb13e8a1a69429fa06a463d8c3071b">More...</a><br /></td></tr>
<tr class="separator:ac3bb13e8a1a69429fa06a463d8c3071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50f91314b4d858ca8beab835733ab3a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab50f91314b4d858ca8beab835733ab3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ab50f91314b4d858ca8beab835733ab3a">solve&lt; 2 &gt;</a> (const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;A, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;b, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;x)</td></tr>
<tr class="memdesc:ab50f91314b4d858ca8beab835733ab3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the solution of A*x = b for 2x2 algebraic system.  <a href="#ab50f91314b4d858ca8beab835733ab3a">More...</a><br /></td></tr>
<tr class="separator:ab50f91314b4d858ca8beab835733ab3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9106ef86205d00ddbeeb590522d4c30b"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a9106ef86205d00ddbeeb590522d4c30b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a9106ef86205d00ddbeeb590522d4c30b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p)</td></tr>
<tr class="separator:a9106ef86205d00ddbeeb590522d4c30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4540428ae313ecb27e2e79ac754773f"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ab4540428ae313ecb27e2e79ac754773f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ab4540428ae313ecb27e2e79ac754773f">operator+</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;v)</td></tr>
<tr class="separator:ab4540428ae313ecb27e2e79ac754773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b41fc6941d5f0eeea34726d2ce5fb9f"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a5b41fc6941d5f0eeea34726d2ce5fb9f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a5b41fc6941d5f0eeea34726d2ce5fb9f">operator+</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p1, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p2)</td></tr>
<tr class="separator:a5b41fc6941d5f0eeea34726d2ce5fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f139b779eca43c72d4fe0bb91656917"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a1f139b779eca43c72d4fe0bb91656917"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a1f139b779eca43c72d4fe0bb91656917">operator-</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p1, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p2)</td></tr>
<tr class="separator:a1f139b779eca43c72d4fe0bb91656917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1e061c40d395ad3265059537742976"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:adc1e061c40d395ad3265059537742976"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#adc1e061c40d395ad3265059537742976">operator*</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p, double s)</td></tr>
<tr class="separator:adc1e061c40d395ad3265059537742976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9f7282ce84d6f9f02f1dead8ce207"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ae3c9f7282ce84d6f9f02f1dead8ce207"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ae3c9f7282ce84d6f9f02f1dead8ce207">operator*</a> (double s, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p)</td></tr>
<tr class="separator:ae3c9f7282ce84d6f9f02f1dead8ce207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf70a08cb30857b30df9d3a36682d8e3"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:adf70a08cb30857b30df9d3a36682d8e3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#adf70a08cb30857b30df9d3a36682d8e3">operator/</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p, double s)</td></tr>
<tr class="separator:adf70a08cb30857b30df9d3a36682d8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e30bc7754b4e6496c51fae638cc776"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a04e30bc7754b4e6496c51fae638cc776"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a04e30bc7754b4e6496c51fae638cc776">operator==</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p1, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p2)</td></tr>
<tr class="separator:a04e30bc7754b4e6496c51fae638cc776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f42cf23e9604717cf6e953f46d9f06"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a27f42cf23e9604717cf6e953f46d9f06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a27f42cf23e9604717cf6e953f46d9f06">approxEq</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p1, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p2, double tol=1.0e-8)</td></tr>
<tr class="separator:a27f42cf23e9604717cf6e953f46d9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114373fc440f684df25612e53c5a13ae"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a114373fc440f684df25612e53c5a13ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a114373fc440f684df25612e53c5a13ae">operator&lt;</a> (const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p1, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;p2)</td></tr>
<tr class="separator:a114373fc440f684df25612e53c5a13ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c455608d7965aed5dd33b1a7530db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Point2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ae9c455608d7965aed5dd33b1a7530db6">ToCylindrical</a> (const <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &amp;p)</td></tr>
<tr class="separator:ae9c455608d7965aed5dd33b1a7530db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b5923fb110da435c886c0ffbc2916"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a504b5923fb110da435c886c0ffbc2916">createP3</a> (double x, double y, double z)</td></tr>
<tr class="separator:a504b5923fb110da435c886c0ffbc2916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5058331c59fc6ec1c9eee58a8ec1b49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Point2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ab5058331c59fc6ec1c9eee58a8ec1b49">createP2</a> (double x, double y)</td></tr>
<tr class="separator:ab5058331c59fc6ec1c9eee58a8ec1b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1c0182d2a727fbb745150d36a8c999"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceTangram.html#a507d2c7fff87afc3f9895cdbfcbb2118">Point1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a2b1c0182d2a727fbb745150d36a8c999">createP1</a> (double x)</td></tr>
<tr class="separator:a2b1c0182d2a727fbb745150d36a8c999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98727a028a358f4388fadeb519401bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceTangram.html#a625f11731b081a330f8829a6a4cb7656">counting_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a98727a028a358f4388fadeb519401bce">make_counting_iterator</a> (int const i)</td></tr>
<tr class="separator:a98727a028a358f4388fadeb519401bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06c411beaeb41e4c0bfcc33aa2aad5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a3d06c411beaeb41e4c0bfcc33aa2aad5"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a3d06c411beaeb41e4c0bfcc33aa2aad5">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>
<tr class="separator:a3d06c411beaeb41e4c0bfcc33aa2aad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8651cb53a5f8abff44af09c97b8560"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:a6e8651cb53a5f8abff44af09c97b8560"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a6e8651cb53a5f8abff44af09c97b8560">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>
<tr class="separator:a6e8651cb53a5f8abff44af09c97b8560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6e4f10705156214e1c923210583834"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:aaa6e4f10705156214e1c923210583834"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aaa6e4f10705156214e1c923210583834">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr class="separator:aaa6e4f10705156214e1c923210583834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2873216e483d671cc6fb4ea26100c1b6"><td class="memTemplParams" colspan="2">template&lt;int D&gt; </td></tr>
<tr class="memitem:a2873216e483d671cc6fb4ea26100c1b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a2873216e483d671cc6fb4ea26100c1b6">operator-</a> (const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; D &gt; &amp;plane)</td></tr>
<tr class="separator:a2873216e483d671cc6fb4ea26100c1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470a7322feda68737ae68a53d47d2418"><td class="memTemplParams" colspan="2">template&lt;int D&gt; </td></tr>
<tr class="memitem:a470a7322feda68737ae68a53d47d2418"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a470a7322feda68737ae68a53d47d2418">overlapping_boxes</a> (const <a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt; D &gt; &amp;bb1, const <a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt; D &gt; &amp;bb2, double dst_eps)</td></tr>
<tr class="separator:a470a7322feda68737ae68a53d47d2418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c08fbbe360adcfed853df8e4027d1d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a8c08fbbe360adcfed853df8e4027d1d2">is_equal</a> (const double fp1, const double fp2)</td></tr>
<tr class="separator:a8c08fbbe360adcfed853df8e4027d1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780072ae7843b354b1ae6b59c3bd3320"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a780072ae7843b354b1ae6b59c3bd3320"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a780072ae7843b354b1ae6b59c3bd3320">sorted_indices</a> (const std::vector&lt; T &gt; &amp;v, bool ascending=true)</td></tr>
<tr class="memdesc:a780072ae7843b354b1ae6b59c3bd3320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of indices corresponding to the ascending or descending order of vector's values.  <a href="#a780072ae7843b354b1ae6b59c3bd3320">More...</a><br /></td></tr>
<tr class="separator:a780072ae7843b354b1ae6b59c3bd3320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3b5ab00373f6e544350802fc83ba88"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a3f3b5ab00373f6e544350802fc83ba88"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a3f3b5ab00373f6e544350802fc83ba88">dot</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;b)</td></tr>
<tr class="memdesc:a3f3b5ab00373f6e544350802fc83ba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of two vectors, \(\vec{a} \cdot \vec{b}\).  <a href="#a3f3b5ab00373f6e544350802fc83ba88">More...</a><br /></td></tr>
<tr class="separator:a3f3b5ab00373f6e544350802fc83ba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0caf4a438812396e8db0e56e5ee297"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a9d0caf4a438812396e8db0e56e5ee297"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a9d0caf4a438812396e8db0e56e5ee297">operator+</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;b)</td></tr>
<tr class="memdesc:a9d0caf4a438812396e8db0e56e5ee297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two vectors.  <a href="#a9d0caf4a438812396e8db0e56e5ee297">More...</a><br /></td></tr>
<tr class="separator:a9d0caf4a438812396e8db0e56e5ee297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55673b512709874418df5c388cd677"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:abc55673b512709874418df5c388cd677"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#abc55673b512709874418df5c388cd677">operator-</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;b)</td></tr>
<tr class="memdesc:abc55673b512709874418df5c388cd677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two vectors.  <a href="#abc55673b512709874418df5c388cd677">More...</a><br /></td></tr>
<tr class="separator:abc55673b512709874418df5c388cd677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee58688682a6838a70a5b4acaa8ddd4"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:a0ee58688682a6838a70a5b4acaa8ddd4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a0ee58688682a6838a70a5b4acaa8ddd4">operator*</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const double &amp;s)</td></tr>
<tr class="memdesc:a0ee58688682a6838a70a5b4acaa8ddd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar, \( s \vec{a}\).  <a href="#a0ee58688682a6838a70a5b4acaa8ddd4">More...</a><br /></td></tr>
<tr class="separator:a0ee58688682a6838a70a5b4acaa8ddd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46283d9c1c220a4a2fee101bc4bdefc"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:aa46283d9c1c220a4a2fee101bc4bdefc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aa46283d9c1c220a4a2fee101bc4bdefc">operator*</a> (const double &amp;s, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a)</td></tr>
<tr class="memdesc:aa46283d9c1c220a4a2fee101bc4bdefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a vector by a scalar, \( s \vec{a}\).  <a href="#aa46283d9c1c220a4a2fee101bc4bdefc">More...</a><br /></td></tr>
<tr class="separator:aa46283d9c1c220a4a2fee101bc4bdefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65f02181ae865524b9fb60ce94cf8ec"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:ab65f02181ae865524b9fb60ce94cf8ec"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ab65f02181ae865524b9fb60ce94cf8ec">operator/</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;a, const double &amp;s)</td></tr>
<tr class="memdesc:ab65f02181ae865524b9fb60ce94cf8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a vector by a scalar, \( \frac{1}{s} \vec{a}\).  <a href="#ab65f02181ae865524b9fb60ce94cf8ec">More...</a><br /></td></tr>
<tr class="separator:ab65f02181ae865524b9fb60ce94cf8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbfb1e1eb1bd8bbf313df4cbdcfbbae"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:aabbfb1e1eb1bd8bbf313df4cbdcfbbae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aabbfb1e1eb1bd8bbf313df4cbdcfbbae">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;v)</td></tr>
<tr class="memdesc:aabbfb1e1eb1bd8bbf313df4cbdcfbbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty printing of a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> to an output stream.  <a href="#aabbfb1e1eb1bd8bbf313df4cbdcfbbae">More...</a><br /></td></tr>
<tr class="separator:aabbfb1e1eb1bd8bbf313df4cbdcfbbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577a00c6410e2ffcdf1666db6e29e9b"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:af577a00c6410e2ffcdf1666db6e29e9b"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#af577a00c6410e2ffcdf1666db6e29e9b">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;v)</td></tr>
<tr class="memdesc:af577a00c6410e2ffcdf1666db6e29e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> from an input stream.  <a href="#af577a00c6410e2ffcdf1666db6e29e9b">More...</a><br /></td></tr>
<tr class="separator:af577a00c6410e2ffcdf1666db6e29e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b9705686c77f9e2022cf7cffb8435c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a84b9705686c77f9e2022cf7cffb8435c">cross</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a84b9705686c77f9e2022cf7cffb8435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product operator for two 2d vectors, \(\vec{a} \times \vec{b}\).  <a href="#a84b9705686c77f9e2022cf7cffb8435c">More...</a><br /></td></tr>
<tr class="separator:a84b9705686c77f9e2022cf7cffb8435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9a148352faf6b196ada2454891eecc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aea9a148352faf6b196ada2454891eecc">cross</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt; &amp;a, const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt; &amp;b)</td></tr>
<tr class="memdesc:aea9a148352faf6b196ada2454891eecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product operator for two 3d vectors, \(\vec{a} \times \vec{b}\).  <a href="#aea9a148352faf6b196ada2454891eecc">More...</a><br /></td></tr>
<tr class="separator:aea9a148352faf6b196ada2454891eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1e4675e88e2f9fc5721337322c37c"><td class="memTemplParams" colspan="2">template&lt;long D&gt; </td></tr>
<tr class="memitem:acbb1e4675e88e2f9fc5721337322c37c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#acbb1e4675e88e2f9fc5721337322c37c">MaxComponent</a> (const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;v, long &amp;icomp)</td></tr>
<tr class="memdesc:acbb1e4675e88e2f9fc5721337322c37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value and index of the maximum component of a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a>.  <a href="#acbb1e4675e88e2f9fc5721337322c37c">More...</a><br /></td></tr>
<tr class="separator:acbb1e4675e88e2f9fc5721337322c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1792d7f4e45f90caeb5ff2a3e775cf"><td class="memTemplParams" colspan="2">template&lt;int D&gt; </td></tr>
<tr class="memitem:abd1792d7f4e45f90caeb5ff2a3e775cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#abd1792d7f4e45f90caeb5ff2a3e775cf">runge_kutta_4</a> (const std::function&lt; <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;(double, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;)&gt; &amp;roc_f, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;x_cur, double t_cur, double dt)</td></tr>
<tr class="memdesc:abd1792d7f4e45f90caeb5ff2a3e775cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth order Runge–Kutta method for initial value problems.  <a href="#abd1792d7f4e45f90caeb5ff2a3e775cf">More...</a><br /></td></tr>
<tr class="separator:abd1792d7f4e45f90caeb5ff2a3e775cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad2fbb26e259abb7a8f8d586ac8e52355"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3">BFGS_ALG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ad2fbb26e259abb7a8f8d586ac8e52355">mof_bfgs_alg</a> = <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3a69c8d5b5c7c91d37e9c7e05fae6d0f86">BFGS</a></td></tr>
<tr class="separator:ad2fbb26e259abb7a8f8d586ac8e52355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c3462626d657aa99bf6b2cd073ba0"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#aa04c3462626d657aa99bf6b2cd073ba0">X</a> = 0</td></tr>
<tr class="separator:aa04c3462626d657aa99bf6b2cd073ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e0faf2a1dc4fb9c9363d884fd0d2ef"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#a92e0faf2a1dc4fb9c9363d884fd0d2ef">Y</a> = 1</td></tr>
<tr class="separator:a92e0faf2a1dc4fb9c9363d884fd0d2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62dfac6275b83587ff60bfbc466be01"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTangram.html#ae62dfac6275b83587ff60bfbc466be01">Z</a> = 2</td></tr>
<tr class="separator:ae62dfac6275b83587ff60bfbc466be01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a625f11731b081a330f8829a6a4cb7656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625f11731b081a330f8829a6a4cb7656">&#9670;&nbsp;</a></span>counting_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::counting_iterator&lt;int&gt; <a class="el" href="namespaceTangram.html#a625f11731b081a330f8829a6a4cb7656">Tangram::counting_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a206c5f2df8e30ec231f93a541c55d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206c5f2df8e30ec231f93a541c55d994">&#9670;&nbsp;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTangram_1_1Point.html">Tangram::Point</a> = typedef Wonton::Point&lt;D&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a507d2c7fff87afc3f9895cdbfcbb2118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507d2c7fff87afc3f9895cdbfcbb2118">&#9670;&nbsp;</a></span>Point1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;1&gt; <a class="el" href="namespaceTangram.html#a507d2c7fff87afc3f9895cdbfcbb2118">Tangram::Point1</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 1d. </p>

</div>
</div>
<a id="a0d7fb85e2d6b6347abfb97f1d8179f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7fb85e2d6b6347abfb97f1d8179f50">&#9670;&nbsp;</a></span>Point2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;2&gt; <a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Tangram::Point2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 2d. </p>

</div>
</div>
<a id="a0d7f6faf100a226eee664d64ef9f725a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f6faf100a226eee664d64ef9f725a">&#9670;&nbsp;</a></span>Point3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;3&gt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Tangram::Point3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for creating a <a class="el" href="classTangram_1_1Point.html" title="Represents a point in an N-dimensional space. ">Point</a> in 3d. </p>

</div>
</div>
<a id="a40e628a70cff126b7d2d71b8143c81ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e628a70cff126b7d2d71b8143c81ee">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceTangram.html#a40e628a70cff126b7d2d71b8143c81ee">Tangram::pointer</a> = typedef std::shared_ptr&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a44825ec386d2499b8ef8c3c1de5c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a44825ec386d2499b8ef8c3c1de5c72">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTangram_1_1Vector.html">Tangram::Vector</a> = typedef Wonton::Vector&lt;D&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71c39deca72d48990415ee231a9170b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c39deca72d48990415ee231a9170b1">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">Tangram::vector</a> = typedef std::vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6d69e9ce03789cdf1605ac0dc93f92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d69e9ce03789cdf1605ac0dc93f92e">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;2&gt; <a class="el" href="namespaceTangram.html#aa6d69e9ce03789cdf1605ac0dc93f92e">Tangram::Vector2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for creating a 3D vector. </p>

</div>
</div>
<a id="a283ae03606aa1f9e34f6f87d7cbb287e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283ae03606aa1f9e34f6f87d7cbb287e">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;3&gt; <a class="el" href="namespaceTangram.html#a283ae03606aa1f9e34f6f87d7cbb287e">Tangram::Vector3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for creating a 3D vector. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acbc93a9c17403e5d2e10e53fb002d1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc93a9c17403e5d2e10e53fb002d1b3">&#9670;&nbsp;</a></span>BFGS_ALG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3">Tangram::BFGS_ALG</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acbc93a9c17403e5d2e10e53fb002d1b3a69c8d5b5c7c91d37e9c7e05fae6d0f86"></a>BFGS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acbc93a9c17403e5d2e10e53fb002d1b3a31463a1a03f66e2d5728a58df0c91305"></a>DBFGS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27f42cf23e9604717cf6e953f46d9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f42cf23e9604717cf6e953f46d9f06">&#9670;&nbsp;</a></span>approxEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::approxEq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.0e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ed879b10eb7c556f505cdaa29bcf0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed879b10eb7c556f505cdaa29bcf0b3">&#9670;&nbsp;</a></span>bfgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;arg_dim&gt; Tangram::bfgs </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>obj_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>obj_fun_lbnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;&#160;</td>
          <td class="paramname"><em>im_tols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BFGS algorithm: finds the minimizer of the objective function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_fun</td><td>Objective function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_guess</td><td>Initial value of the argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num_iter</td><td>Maximum number of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im_tols</td><td>Tolerances </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the minimizer </dd></dl>

</div>
</div>
<a id="a89fb672bd64174fd73fc2854ab52e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fb672bd64174fd73fc2854ab52e0c3">&#9670;&nbsp;</a></span>cartesian_to_polar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;1&gt; Tangram::cartesian_to_polar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>cartesian_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0962fe321eb5d6aebe45bc5c7758840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0962fe321eb5d6aebe45bc5c7758840">&#9670;&nbsp;</a></span>cartesian_to_polar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;2&gt; Tangram::cartesian_to_polar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>cartesian_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a082d6df64712201cc18e4a3228eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a082d6df64712201cc18e4a3228eecc">&#9670;&nbsp;</a></span>cell_get_matpoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::cell_get_matpoly </td>
          <td>(</td>
          <td class="paramtype">const Mesh_Wrapper &amp;&#160;</td>
          <td class="paramname"><em>Mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a material polygon that corresponds to (i.e. has the same geometry as) a given mesh cell. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mesh_Wrapper</td><td>A lightweight wrapper to a specific input mesh implementation that provides certain functionality</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mesh</td><td>Mesh wrapper </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellid</td><td>Index of a cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat_poly</td><td>Pointer to the material polygon to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance to be used by that material polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e78b490c82464a056ec64a36ee2e387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e78b490c82464a056ec64a36ee2e387">&#9670;&nbsp;</a></span>cell_get_matpoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::cell_get_matpoly </td>
          <td>(</td>
          <td class="paramtype">const Mesh_Wrapper &amp;&#160;</td>
          <td class="paramname"><em>Mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cellid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a material polyhedron that corresponds to (i.e. has the same geometry as) a given mesh cell. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mesh_Wrapper</td><td>A lightweight wrapper to a specific input mesh implementation that provides certain functionality</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mesh</td><td>Mesh wrapper </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cellid</td><td>Index of a cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat_poly</td><td>Pointer to the material polyhedron to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance to be used by that material polyhedron </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc8686bea4d2f435f2546c28f8996b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8686bea4d2f435f2546c28f8996b58">&#9670;&nbsp;</a></span>cen_diff_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::cen_diff_grad </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>approx_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fdiff_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Central finite difference approximation of a gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Function for which we compute the gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg_val</td><td>We approximate the gradient for this value of the argument </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">approx_grad</td><td>Computed approximation of the gradient at arg_val </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdiff_h</td><td>Finite difference step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b1c0182d2a727fbb745150d36a8c999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1c0182d2a727fbb745150d36a8c999">&#9670;&nbsp;</a></span>createP1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceTangram.html#a507d2c7fff87afc3f9895cdbfcbb2118">Point1</a> Tangram::createP1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5058331c59fc6ec1c9eee58a8ec1b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5058331c59fc6ec1c9eee58a8ec1b49">&#9670;&nbsp;</a></span>createP2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Point2</a> Tangram::createP2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a504b5923fb110da435c886c0ffbc2916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504b5923fb110da435c886c0ffbc2916">&#9670;&nbsp;</a></span>createP3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> Tangram::createP3 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84b9705686c77f9e2022cf7cffb8435c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b9705686c77f9e2022cf7cffb8435c">&#9670;&nbsp;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product operator for two 2d vectors, \(\vec{a} \times \vec{b}\). </p>

</div>
</div>
<a id="aea9a148352faf6b196ada2454891eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9a148352faf6b196ada2454891eecc">&#9670;&nbsp;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;3&gt; Tangram::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product operator for two 3d vectors, \(\vec{a} \times \vec{b}\). </p>

</div>
</div>
<a id="a22b16d21c00e552fb22347aec9c972a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b16d21c00e552fb22347aec9c972a6">&#9670;&nbsp;</a></span>dbfgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;arg_dim&gt; Tangram::dbfgs </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>obj_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>obj_fun_lbnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;&#160;</td>
          <td class="paramname"><em>im_tols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>D-BFGS algorithm: finds the minimizer of the objective function Based on "Improved Damped Quasi-Newton Methods for Unconstrained Optimization" by Mehiddin Al-Baali and Lucio Grandinetti, Pacific Journal of Optimization (to appear). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_fun</td><td>Objective function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_guess</td><td>Initial value of the argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num_iter</td><td>Maximum number of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im_tols</td><td>Tolerances </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the minimizer </dd></dl>

</div>
</div>
<a id="a3f3b5ab00373f6e544350802fc83ba88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3b5ab00373f6e544350802fc83ba88">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product of two vectors, \(\vec{a} \cdot \vec{b}\). </p>

</div>
</div>
<a id="ac0b5db50aff69e0d2ff71bf6c6d79aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b5db50aff69e0d2ff71bf6c6d79aa7">&#9670;&nbsp;</a></span>finite_diff_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::finite_diff_grad </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fun_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rel_err_bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>approx_grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finite difference approximation of a gradient. Switches from forward to central finite differences if the value of the gradient is not significant relative to the method's error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Function for which we compute the gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg_val</td><td>We approximate the gradient for this value of the argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun_val</td><td>Value of function at arg_val </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_err_bnd</td><td>If the estimate of relative error in gradient is above this, we switch from forward to central finite differences </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">approx_grad</td><td>Computed approximation of the gradient at arg_val </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa6e4f10705156214e1c923210583834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6e4f10705156214e1c923210583834">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::for_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad19d39ec7ebae38d35674f4e3630ddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19d39ec7ebae38d35674f4e3630ddaa">&#9670;&nbsp;</a></span>fwd_diff_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::fwd_diff_grad </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fun_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>approx_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fdiff_h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward finite difference approximation of a gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>Function for which we compute the gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg_val</td><td>We approximate the gradient for this value of the argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun_val</td><td>Value of function at arg_val </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">approx_grad</td><td>Computed approximation of the gradient at arg_val </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdiff_h</td><td>Finite difference step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76c203c6b6098cf8d1a6aaa44f6129c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c203c6b6098cf8d1a6aaa44f6129c1">&#9670;&nbsp;</a></span>get_intersection_moments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::get_intersection_moments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r2dpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersection_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convex_matpoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes moments of the intersection of a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> and an <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a>. If <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex, <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a> will be clipped with lines containing the faces of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>. Otherwise, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> will be decomposed into triangular MatPolys, each of which will be intersected with <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a>. Note that <a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a> does not need to be convex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to intersect with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r2dpoly</td><td><a class="el" href="structr2d__poly.html" title="A polygon. Can be convex, nonconvex, even multiply-connected. ">r2d_poly</a> that is intersected with <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection_moments</td><td>Moments of the intersection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex_matpoly</td><td>flag indicating if <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex: if not it will be decomposed into triangles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04f943054dc7440e73891fa687911b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f943054dc7440e73891fa687911b14">&#9670;&nbsp;</a></span>get_intersection_moments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::get_intersection_moments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r3dpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersection_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convex_matpoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes moments of the intersection of a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> and an <a class="el" href="structr3d__poly.html">r3d_poly</a>. If <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex, <a class="el" href="structr3d__poly.html">r3d_poly</a> will be clipped with planes containing the faces of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>. Otherwise, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> will be decomposed into tetrahedral MatPolys, each of which will be intersected with <a class="el" href="structr3d__poly.html">r3d_poly</a>. Note that <a class="el" href="structr3d__poly.html">r3d_poly</a> does not need to be convex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to intersect with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r3dpoly</td><td><a class="el" href="structr3d__poly.html">r3d_poly</a> that is intersected with <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection_moments</td><td>Moments of the intersection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex_matpoly</td><td>flag indicating if <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex: if not it will be decomposed into tetrahedra</td></tr>
  </table>
  </dd>
</dl>
<p>Computes moments of the intersection of a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> and an <a class="el" href="structr3d__poly.html">r3d_poly</a>. If <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex, <a class="el" href="structr3d__poly.html">r3d_poly</a> will be clipped with planes containing the faces of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>. Otherwise, <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> will be decomposed into tetrahedral MatPolys, each of which will be intersected with <a class="el" href="structr3d__poly.html">r3d_poly</a>. Note that <a class="el" href="structr3d__poly.html">r3d_poly</a> does not need to be convex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to intersect with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r3dpoly</td><td><a class="el" href="structr3d__poly.html">r3d_poly</a> that is intersected with <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection_moments</td><td>Moments of the intersection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex_matpoly</td><td>flag indicating if <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex: if not it will be decomposed into tetrahedra </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c08fbbe360adcfed853df8e4027d1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c08fbbe360adcfed853df8e4027d1d2">&#9670;&nbsp;</a></span>is_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::is_equal </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89f74efa496fa4e1c06b3e39a788ee78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f74efa496fa4e1c06b3e39a788ee78">&#9670;&nbsp;</a></span>linesearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int arg_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::linesearch </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>obj_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>obj_fun_lbnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &amp;&#160;</td>
          <td class="paramname"><em>im_tols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rel_err_bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cur_fval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; arg_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cur_grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linesearch algorithm: finds the argument satisfying the strong Wolfe conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_fun</td><td>Objective function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Current argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>Linesearch direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_guess</td><td>Starting value of the argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c1</td><td>Value of c1 parameter in Wolfe conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c2</td><td>Value of c2 parameter in Wolfe conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im_tols</td><td>Tolerances </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rel_err_bnd</td><td>If the estimate of relative error in gradient is above this, we switch from forward to central finite differences </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afef97752fc2daf4936063c41dbbc9abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef97752fc2daf4936063c41dbbc9abd">&#9670;&nbsp;</a></span>ls_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::ls_gradient </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute least squares gradient from set of values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coords</td><td><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of coordinates at which values are given </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of values at said coordinates</td></tr>
  </table>
  </dd>
</dl>
<p>Compute a least squares gradient from a set of values. The first point is assumed to be the point where the gradient must be computed and the first value is assumed to the value at this reference point</p>
<p>This operator does not know anything about a mesh. </p>

</div>
</div>
<a id="a98727a028a358f4388fadeb519401bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98727a028a358f4388fadeb519401bce">&#9670;&nbsp;</a></span>make_counting_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTangram.html#a625f11731b081a330f8829a6a4cb7656">counting_iterator</a> Tangram::make_counting_iterator </td>
          <td>(</td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae282114f99c97df0c59c6006bc065e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae282114f99c97df0c59c6006bc065e0b">&#9670;&nbsp;</a></span>matpoly_to_r2dpoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::matpoly_to_r2dpoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r2dpoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to a polygon in R2D format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to convert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r2dpoly</td><td>Corresponding R2D polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2364ea47380698d6b380574978c068da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2364ea47380698d6b380574978c068da">&#9670;&nbsp;</a></span>matpoly_to_r3dpoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::matpoly_to_r3dpoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r3dpoly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to a polyhedron in R3D format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to convert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r3dpoly</td><td>Corresponding R3D polyhedron </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbb1e4675e88e2f9fc5721337322c37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb1e4675e88e2f9fc5721337322c37c">&#9670;&nbsp;</a></span>MaxComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::MaxComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>icomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the value and index of the maximum component of a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The input <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">icomp</td><td>The index of the maximum component of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum component of <code>v</code>. </dd></dl>

</div>
</div>
<a id="a69297ec3a4d9448be375b217d7297fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69297ec3a4d9448be375b217d7297fe9">&#9670;&nbsp;</a></span>natural_selection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt;2&gt; Tangram::natural_selection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; *&#160;</td>
          <td class="paramname"><em>reference_pts</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminates degenerate faces from a polygon given by a sequence of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_points</td><td>Vertices of the polygon in the counter-clockwise order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_pts</td><td>Preferred points to snap vertices to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> with no degeneracies </dd></dl>

</div>
</div>
<a id="a9cf0201d875a729c2ab615434bf540e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf0201d875a729c2ab615434bf540e5">&#9670;&nbsp;</a></span>natural_selection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt;3&gt; Tangram::natural_selection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &gt; *&#160;</td>
          <td class="paramname"><em>reference_pts</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eliminates degeneracies from the boundary representation, which includes vertices within distance tolerance from other vertices, hanging nodes, and degenerate faces with less than three vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_points</td><td>Vertices of the polyhedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_vertices</td><td>Faces of the polyhedron, every face is given by IDs of its vertices in counter-clockwise order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_pts</td><td>Preferred points to snap vertices to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> with no degeneracies </dd></dl>

</div>
</div>
<a id="adc1e061c40d395ad3265059537742976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1e061c40d395ad3265059537742976">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3c9f7282ce84d6f9f02f1dead8ce207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c9f7282ce84d6f9f02f1dead8ce207">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ee58688682a6838a70a5b4acaa8ddd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee58688682a6838a70a5b4acaa8ddd4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar, \( s \vec{a}\). </p>

</div>
</div>
<a id="aa46283d9c1c220a4a2fee101bc4bdefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46283d9c1c220a4a2fee101bc4bdefc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a vector by a scalar, \( s \vec{a}\). </p>

</div>
</div>
<a id="ac65f42d8d4c6ad3e9f15de6b726a6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65f42d8d4c6ad3e9f15de6b726a6f5d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a274802a8b305a6b25bda1228da151468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274802a8b305a6b25bda1228da151468">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aeb9044b063e89a62f780a8493a97d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeb9044b063e89a62f780a8493a97d3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Matrix.html">Matrix</a> Tangram::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4540428ae313ecb27e2e79ac754773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4540428ae313ecb27e2e79ac754773f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b41fc6941d5f0eeea34726d2ce5fb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b41fc6941d5f0eeea34726d2ce5fb9f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d0caf4a438812396e8db0e56e5ee297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0caf4a438812396e8db0e56e5ee297">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two vectors. </p>

</div>
</div>
<a id="ad01579d0f4681395bfdee1613d047b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01579d0f4681395bfdee1613d047b55">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> Tangram::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2873216e483d671cc6fb4ea26100c1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2873216e483d671cc6fb4ea26100c1b6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt;D&gt; Tangram::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f139b779eca43c72d4fe0bb91656917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f139b779eca43c72d4fe0bb91656917">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc55673b512709874418df5c388cd677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55673b512709874418df5c388cd677">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two vectors. </p>

</div>
</div>
<a id="a38482a96ce72f503485a3955808503a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38482a96ce72f503485a3955808503a0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> Tangram::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract two materices. </p>

</div>
</div>
<a id="adf70a08cb30857b30df9d3a36682d8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf70a08cb30857b30df9d3a36682d8e3">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65f02181ae865524b9fb60ce94cf8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65f02181ae865524b9fb60ce94cf8ec">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;D&gt; Tangram::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a vector by a scalar, \( \frac{1}{s} \vec{a}\). </p>

</div>
</div>
<a id="a114373fc440f684df25612e53c5a13ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114373fc440f684df25612e53c5a13ae">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9106ef86205d00ddbeeb590522d4c30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9106ef86205d00ddbeeb590522d4c30b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Tangram::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aabbfb1e1eb1bd8bbf313df4cbdcfbbae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbfb1e1eb1bd8bbf313df4cbdcfbbae">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Tangram::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pretty printing of a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> to an output stream. </p>

</div>
</div>
<a id="a04e30bc7754b4e6496c51fae638cc776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e30bc7754b4e6496c51fae638cc776">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af577a00c6410e2ffcdf1666db6e29e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af577a00c6410e2ffcdf1666db6e29e9b">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; Tangram::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> from an input stream. </p>

</div>
</div>
<a id="a470a7322feda68737ae68a53d47d2418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470a7322feda68737ae68a53d47d2418">&#9670;&nbsp;</a></span>overlapping_boxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::overlapping_boxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>bb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>bb2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06e9c97f69aeca40afb983ab4c229059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e9c97f69aeca40afb983ab4c229059">&#9670;&nbsp;</a></span>point_inside_matpoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tangram::point_inside_matpoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convex_poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given point is interior wrt to a given polyhedron. Note: boundary points are no considered to be interior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td>A given polyhedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>A given point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex_poly</td><td>Flag to indicate if the given <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> is convex: if set to false, it will be decomposed into tetrahedrons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the point is in the interior of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> </dd></dl>

</div>
</div>
<a id="a59d180681d4c78fd3288902c7101a91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d180681d4c78fd3288902c7101a91a">&#9670;&nbsp;</a></span>polar_to_cartesian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;2&gt; Tangram::polar_to_cartesian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>polar_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade0b6a408ae03bac84775e2a263a7e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0b6a408ae03bac84775e2a263a7e7a">&#9670;&nbsp;</a></span>polar_to_cartesian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;3&gt; Tangram::polar_to_cartesian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>polar_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add95776fd9a423b220c590e28f32fd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add95776fd9a423b220c590e28f32fd22">&#9670;&nbsp;</a></span>polygon3d_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::polygon3d_area </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0379ce04695d2beacee8173ab40f62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0379ce04695d2beacee8173ab40f62b">&#9670;&nbsp;</a></span>polygon3d_moments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::polygon3d_moments </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a498a02ba72d13092913c9ac3d5a7f8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498a02ba72d13092913c9ac3d5a7f8b2">&#9670;&nbsp;</a></span>polygon3d_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt;3&gt; Tangram::polygon3d_normal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74a22f853981042ff40dbe7bed31dc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a22f853981042ff40dbe7bed31dc17">&#9670;&nbsp;</a></span>quad_interpolant_minimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Tangram::quad_interpolant_minimizer </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fval0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fval1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>df0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>safeguards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimizer of a quadratic interpolant in the interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg0</td><td>End of the domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg1</td><td>Other end of the domain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fval0</td><td>Value of the function at arg0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fval1</td><td>Value of the function at arg1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df0</td><td>Value of the derivative at arg0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">safeguards</td><td>Two-element array to keep the minimizer away from the boundaries of the domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the minimizer </dd></dl>

</div>
</div>
<a id="a7012e7bb1d6b908e25f8426430e11de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7012e7bb1d6b908e25f8426430e11de2">&#9670;&nbsp;</a></span>r2dpoly_to_matpoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::r2dpoly_to_matpoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structr2d__poly.html">r2d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r2dpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 2 &gt; &gt; *&#160;</td>
          <td class="paramname"><em>reference_pts</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a R2D poly to a <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> where the vertices in the Matpoly are ordered counter clock-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r2dpoly</td><td>Corresponding R2D polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> object to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_pts</td><td>Preferred points to snap vertices to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a989a601d36db6dab4fcec22ed85fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a989a601d36db6dab4fcec22ed85fe">&#9670;&nbsp;</a></span>r3d_poly_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTangram_1_1BoundingBox__t.html">BoundingBox_t</a>&lt;3&gt; Tangram::r3d_poly_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r3dpoly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43906bb61091453a4fc320c983f9c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43906bb61091453a4fc320c983f9c733">&#9670;&nbsp;</a></span>r3d_poly_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::r3d_poly_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r3dpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structr3d__poly.html">r3d_poly</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>vol_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks an <a class="el" href="structr3d__poly.html">r3d_poly</a> into a vector of disjoint components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r3dpoly</td><td>Original r3dpoly that can have disjoint components </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poly_components</td><td><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of r3dpoly's, one for each components </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vol_tol</td><td>Volume tolerance, only components with volumes above it will be included in the output vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8da5e3ebb9e36f354b8d4351050c246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8da5e3ebb9e36f354b8d4351050c246">&#9670;&nbsp;</a></span>r3dpoly_to_matpolys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::r3dpoly_to_matpolys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structr3d__poly.html">r3d_poly</a> &amp;&#160;</td>
          <td class="paramname"><em>r3dpoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>vol_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dst_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; 3 &gt; &gt; *&#160;</td>
          <td class="paramname"><em>reference_pts</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a polyhedron in R3D format to <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r3dpoly</td><td>R3D polyhedron to convert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat_polys</td><td>Corresponding vector of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s: will contain as many <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s as there are components in the R3D polyhedron </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_tol</td><td>Distance tolerance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_pts</td><td>Preferred points to snap vertices to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd1792d7f4e45f90caeb5ff2a3e775cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1792d7f4e45f90caeb5ff2a3e775cf">&#9670;&nbsp;</a></span>runge_kutta_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1Point.html">Point</a>&lt;D&gt; Tangram::runge_kutta_4 </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt;(double, const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>roc_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t_cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fourth order Runge–Kutta method for initial value problems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roc_f</td><td>Rate of change function for x, dx/dt=roc_f(t, x) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_cur</td><td>Current value of x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t_cur</td><td>Current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time step </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of x after the time step </dd></dl>

</div>
</div>
<a id="a631a6c3d59a5f65098fb653ed54cabfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631a6c3d59a5f65098fb653ed54cabfb">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;long D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the solution of A*x = b using the QR decomposition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>Indicates the dimensionality of the <a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The system right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3bb13e8a1a69429fa06a463d8c3071b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bb13e8a1a69429fa06a463d8c3071b">&#9670;&nbsp;</a></span>solve< 1 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceTangram.html#a631a6c3d59a5f65098fb653ed54cabfb">Tangram::solve</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the solution of A*x = b for 1x1 algebraic system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The system right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50f91314b4d858ca8beab835733ab3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50f91314b4d858ca8beab835733ab3a">&#9670;&nbsp;</a></span>solve< 2 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceTangram.html#a631a6c3d59a5f65098fb653ed54cabfb">Tangram::solve</a>&lt; 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1Vector.html">Vector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the solution of A*x = b for 2x2 algebraic system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The system matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The system right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a780072ae7843b354b1ae6b59c3bd3320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780072ae7843b354b1ae6b59c3bd3320">&#9670;&nbsp;</a></span>sorted_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Tangram::sorted_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sequence of indices corresponding to the ascending or descending order of vector's values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the vector's values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of type T </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascending</td><td>If true, values are to be ascending, otherwise descending </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of indices in the order corresponding to the ascending/descending values of v </dd></dl>

</div>
</div>
<a id="a5551f71f2e6bd3082c4f9756d55d9f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5551f71f2e6bd3082c4f9756d55d9f33">&#9670;&nbsp;</a></span>split_convex_matpoly_r2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::split_convex_matpoly_r2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutting_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_halfspace_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_halfspace_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_halfspace_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_halfspace_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> into two (convex) <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s with a cutting plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td>Convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutting_plane</td><td>Cutting plane to split with </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_halfspace_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> below the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_halfspace_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> above the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_halfspace_moments</td><td>Moments of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> below the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_halfspace_moments</td><td>Moments of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> above the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d36b5dbc71670d73c1b6d326fa81a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d36b5dbc71670d73c1b6d326fa81a85">&#9670;&nbsp;</a></span>split_convex_matpoly_r3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::split_convex_matpoly_r3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutting_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_halfspace_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_halfspace_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_halfspace_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_halfspace_moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> into two (convex) <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>'s with a cutting plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_poly</td><td>Convex <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> to split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cutting_plane</td><td>Cutting plane to split with </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_halfspace_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> below the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_halfspace_poly</td><td><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> above the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower_halfspace_moments</td><td>Moments of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> below the plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper_halfspace_moments</td><td>Moments of <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> above the plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9c455608d7965aed5dd33b1a7530db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c455608d7965aed5dd33b1a7530db6">&#9670;&nbsp;</a></span>ToCylindrical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceTangram.html#a0d7fb85e2d6b6347abfb97f1d8179f50">Point2</a> Tangram::ToCylindrical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceTangram.html#a0d7f6faf100a226eee664d64ef9f725a">Point3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d06c411beaeb41e4c0bfcc33aa2aad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d06c411beaeb41e4c0bfcc33aa2aad5">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Tangram::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e8651cb53a5f8abff44af09c97b8560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8651cb53a5f8abff44af09c97b8560">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator Tangram::transform </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4eca4fe70b7096799ce9a4717b0457a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4eca4fe70b7096799ce9a4717b0457a">&#9670;&nbsp;</a></span>write_to_gmv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::write_to_gmv </td>
          <td>(</td>
          <td class="paramtype">Mesh_Wrapper const &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_num_mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_mat_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt; D &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>cellmatpoly_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08829fb30da7bfef5b1d182ce2e6c820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08829fb30da7bfef5b1d182ce2e6c820">&#9670;&nbsp;</a></span>write_to_gmv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Tangram::write_to_gmv </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt; D &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cellmatpoly_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad2fbb26e259abb7a8f8d586ac8e52355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fbb26e259abb7a8f8d586ac8e52355">&#9670;&nbsp;</a></span>mof_bfgs_alg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3">BFGS_ALG</a> Tangram::mof_bfgs_alg = <a class="el" href="namespaceTangram.html#acbc93a9c17403e5d2e10e53fb002d1b3a69c8d5b5c7c91d37e9c7e05fae6d0f86">BFGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04c3462626d657aa99bf6b2cd073ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04c3462626d657aa99bf6b2cd073ba0">&#9670;&nbsp;</a></span>X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Tangram::X = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92e0faf2a1dc4fb9c9363d884fd0d2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e0faf2a1dc4fb9c9363d884fd0d2ef">&#9670;&nbsp;</a></span>Y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Tangram::Y = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae62dfac6275b83587ff60bfbc466be01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62dfac6275b83587ff60bfbc466be01">&#9670;&nbsp;</a></span>Z</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Tangram::Z = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
