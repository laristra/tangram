<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>tangram: Tangram::MOF&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTangram.html">Tangram</a></li><li class="navelem"><a class="el" href="classTangram_1_1MOF.html">MOF</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classTangram_1_1MOF-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tangram::MOF&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MOF_8h_source.html">MOF.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30b558a6b614b8b8f03b86819160af11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a30b558a6b614b8b8f03b86819160af11">MOF</a> (const Mesh_Wrapper &amp;Mesh, const std::vector&lt; <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &gt; &amp;ims_tols, const bool all_convex)</td></tr>
<tr class="memdesc:a30b558a6b614b8b8f03b86819160af11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="classTangram_1_1MOF.html">MOF</a> interface reconstruction algorithm.  <a href="#a30b558a6b614b8b8f03b86819160af11">More...</a><br /></td></tr>
<tr class="separator:a30b558a6b614b8b8f03b86819160af11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11029c5cdca38be7ae2a794c01fb35c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a11029c5cdca38be7ae2a794c01fb35c1">set_volume_fractions</a> (std::vector&lt; int &gt; const &amp;cell_num_mats, std::vector&lt; int &gt; const &amp;cell_mat_ids, std::vector&lt; double &gt; const &amp;cell_mat_volfracs, std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; Dim &gt;&gt; const &amp;cell_mat_centroids)</td></tr>
<tr class="memdesc:a11029c5cdca38be7ae2a794c01fb35c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in the volume fraction data for use in the reconstruction.  <a href="#a11029c5cdca38be7ae2a794c01fb35c1">More...</a><br /></td></tr>
<tr class="separator:a11029c5cdca38be7ae2a794c01fb35c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121bfee6da0fc4ed4cd9da9820d39106"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a121bfee6da0fc4ed4cd9da9820d39106">iterative_methods_tolerances</a> () const</td></tr>
<tr class="memdesc:a121bfee6da0fc4ed4cd9da9820d39106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used iterative methods tolerances.  <a href="#a121bfee6da0fc4ed4cd9da9820d39106">More...</a><br /></td></tr>
<tr class="separator:a121bfee6da0fc4ed4cd9da9820d39106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd922d2966f3fe641f1cbe118bc64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a16dd922d2966f3fe641f1cbe118bc64c">set_cell_indices_to_operate_on</a> (std::vector&lt; int &gt; const &amp;cellIDs_to_op_on)</td></tr>
<tr class="memdesc:a16dd922d2966f3fe641f1cbe118bc64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in indices of cells for which <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> objects are to be constructed. If the index is in the list, a <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> object will be created even for a single-material cell.  <a href="#a16dd922d2966f3fe641f1cbe118bc64c">More...</a><br /></td></tr>
<tr class="separator:a16dd922d2966f3fe641f1cbe118bc64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10f7b2736fd816cdfc3e156ad997f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#ad10f7b2736fd816cdfc3e156ad997f63">get_plane_position</a> (const int cellID, const int matID, const std::vector&lt; <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; Dim &gt; &gt; &amp;mixed_polys, <a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; Dim &gt; &amp;cutting_plane, const bool planar_faces) const</td></tr>
<tr class="memdesc:ad10f7b2736fd816cdfc3e156ad997f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the position of a plane that clips off a particular material. This method is used on every step of the nested dissections algorithm. Note that if MatPoly_Clipper can handle non-convex cells, this method does not require decomposion into tetrahedrons.  <a href="#ad10f7b2736fd816cdfc3e156ad997f63">More...</a><br /></td></tr>
<tr class="separator:ad10f7b2736fd816cdfc3e156ad997f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255b4430444fc7fabc3e24eb771ee72f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt; Dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a255b4430444fc7fabc3e24eb771ee72f">operator()</a> (const int cell_op_ID) const</td></tr>
<tr class="memdesc:a255b4430444fc7fabc3e24eb771ee72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cell index, calculate the <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> using the <a class="el" href="classTangram_1_1MOF.html">MOF</a> interface reconstruction method. Uses nested dissections algorithm.  <a href="#a255b4430444fc7fabc3e24eb771ee72f">More...</a><br /></td></tr>
<tr class="separator:a255b4430444fc7fabc3e24eb771ee72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df855ca2c1dfc410a61c82fc6fa1488"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#a8df855ca2c1dfc410a61c82fc6fa1488">cell_materials</a> (const int cellID) const</td></tr>
<tr class="memdesc:a8df855ca2c1dfc410a61c82fc6fa1488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materials in the cell.  <a href="#a8df855ca2c1dfc410a61c82fc6fa1488">More...</a><br /></td></tr>
<tr class="separator:a8df855ca2c1dfc410a61c82fc6fa1488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb19fc7794fa3bff0a12a2b614db0ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; Dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTangram_1_1MOF.html#acb19fc7794fa3bff0a12a2b614db0ad9">cell_matpoly</a> (const int cellID) const</td></tr>
<tr class="memdesc:acb19fc7794fa3bff0a12a2b614db0ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> corresponding to a mesh cell.  <a href="#acb19fc7794fa3bff0a12a2b614db0ad9">More...</a><br /></td></tr>
<tr class="separator:acb19fc7794fa3bff0a12a2b614db0ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a30b558a6b614b8b8f03b86819160af11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b558a6b614b8b8f03b86819160af11">&#9670;&nbsp;</a></span>MOF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::<a class="el" href="classTangram_1_1MOF.html">MOF</a> </td>
          <td>(</td>
          <td class="paramtype">const Mesh_Wrapper &amp;&#160;</td>
          <td class="paramname"><em>Mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ims_tols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all_convex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="classTangram_1_1MOF.html">MOF</a> interface reconstruction algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mesh</td><td>A lightweight wrapper to a specific input mesh implementation that provides certain functionality </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ims_tols</td><td>Tolerances for iterative methods </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all_convex</td><td>Flag indicating whether all mesh cells are convex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8df855ca2c1dfc410a61c82fc6fa1488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df855ca2c1dfc410a61c82fc6fa1488">&#9670;&nbsp;</a></span>cell_materials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::cell_materials </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cellID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Materials in the cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellID</td><td>Cell index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of indices of cell's materials </dd></dl>

</div>
</div>
<a id="acb19fc7794fa3bff0a12a2b614db0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb19fc7794fa3bff0a12a2b614db0ad9">&#9670;&nbsp;</a></span>cell_matpoly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt;Dim&gt; <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::cell_matpoly </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cellID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> corresponding to a mesh cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellID</td><td>Cell index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a> for this cell </dd></dl>

</div>
</div>
<a id="ad10f7b2736fd816cdfc3e156ad997f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10f7b2736fd816cdfc3e156ad997f63">&#9670;&nbsp;</a></span>get_plane_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::get_plane_position </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cellID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>matID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTangram_1_1MatPoly.html">MatPoly</a>&lt; Dim &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mixed_polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTangram_1_1Plane__t.html">Plane_t</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutting_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>planar_faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the position of a plane that clips off a particular material. This method is used on every step of the nested dissections algorithm. Note that if MatPoly_Clipper can handle non-convex cells, this method does not require decomposion into tetrahedrons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellID</td><td>Index of the multi-material cell to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matID</td><td>Index of the material to clip </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mixed_polys</td><td><a class="el" href="classTangram_1_1Vector.html" title="Represents a vector in N-dimensional space. ">Vector</a> of material poly's that contain the material to clip and (possibly) other materials </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cutting_plane</td><td>The resulting cutting plane position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planar_faces</td><td>Flag indicating whether the faces of all mixed_polys are planar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a121bfee6da0fc4ed4cd9da9820d39106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121bfee6da0fc4ed4cd9da9820d39106">&#9670;&nbsp;</a></span>iterative_methods_tolerances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structTangram_1_1IterativeMethodTolerances__t.html">IterativeMethodTolerances_t</a>&gt;&amp; <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::iterative_methods_tolerances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used iterative methods tolerances. </p>
<dl class="section return"><dt>Returns</dt><dd>Tolerances for iterative methods, here ims_tols_[0] correspond to methods for volumes and ims_tols_[1] correspond to methods for centroids. In particular, ims_tols_[0].arg_eps is a negligible change in cutting distance, ims_tols_[0].fun_eps is a negligible discrepancy in volume, ims_tols_[1].arg_eps is a negligible change in the cutting plane orientation, and ims_tols_[1].fun_eps is a negligible distance between actual and reference centroids. The change in cutting plane orientation is defined as the norm of change of the cutting plane's normal, which is expressed in polar coordinates (angles). </dd></dl>

</div>
</div>
<a id="a255b4430444fc7fabc3e24eb771ee72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255b4430444fc7fabc3e24eb771ee72f">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a>&lt;Dim&gt; &gt; <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cell_op_ID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a cell index, calculate the <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> using the <a class="el" href="classTangram_1_1MOF.html">MOF</a> interface reconstruction method. Uses nested dissections algorithm. </p>

</div>
</div>
<a id="a16dd922d2966f3fe641f1cbe118bc64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dd922d2966f3fe641f1cbe118bc64c">&#9670;&nbsp;</a></span>set_cell_indices_to_operate_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::set_cell_indices_to_operate_on </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cellIDs_to_op_on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in indices of cells for which <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> objects are to be constructed. If the index is in the list, a <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> object will be created even for a single-material cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cellIDs_to_op_on</td><td>A vector of length up to (num_cells) specifying the indices of cells for which <a class="el" href="classTangram_1_1CellMatPoly.html">CellMatPoly</a> objects are requested. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11029c5cdca38be7ae2a794c01fb35c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11029c5cdca38be7ae2a794c01fb35c1">&#9670;&nbsp;</a></span>set_volume_fractions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mesh_Wrapper , int Dim, class MatPoly_Splitter , class MatPoly_Clipper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTangram_1_1MOF.html">Tangram::MOF</a>&lt; Mesh_Wrapper, Dim, MatPoly_Splitter, MatPoly_Clipper &gt;::set_volume_fractions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_num_mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_mat_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_mat_volfracs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTangram_1_1Point.html">Point</a>&lt; Dim &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>cell_mat_centroids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in the volume fraction data for use in the reconstruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_num_mats</td><td>A vector of length (num_cells) specifying the number of materials in each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_mat_ids</td><td>A vector of length (sum(cell_num_mats)) specifying the ID of each material in each cell </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_mat_volfracs</td><td>A vector of length(sum(cell_num_mats)) specifying the volume fraction of each material in each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/portage/tangram/tangram/reconstruct/<a class="el" href="MOF_8h_source.html">MOF.h</a></li>
</ul>
</div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
